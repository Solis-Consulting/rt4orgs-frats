<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>RT4 Lead Console</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 0; background: #0f172a; color: #e5e7eb; }
    .shell { max-width: 1100px; margin: 32px auto; padding: 0 16px; }
    .card { background: #020617; border-radius: 16px; padding: 20px 24px; box-shadow: 0 18px 60px rgba(0,0,0,0.6); border: 1px solid #1f2937; }
    h1 { margin: 0 0 8px; font-size: 24px; }
    .sub { margin-bottom: 16px; color: #9ca3af; font-size: 14px; }
    .toolbar { display: flex; gap: 12px; align-items: center; margin-bottom: 16px; flex-wrap: wrap; }
    input, select { background: #020617; border: 1px solid #4b5563; border-radius: 8px; padding: 6px 10px; color: #e5e7eb; font-size: 13px; }
    input:focus, select:focus { outline: none; border-color: #38bdf8; }
    .pill-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .pill { font-size: 11px; padding: 4px 10px; border-radius: 999px; border: 1px solid #374151; cursor: pointer; color: #9ca3af; }
    .pill.active { background: #0ea5e9; border-color: #0ea5e9; color: #0f172a; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; margin-top: 8px; }
    th, td { padding: 8px 6px; text-align: left; border-bottom: 1px solid #1f2937; }
    th { font-size: 11px; text-transform: uppercase; letter-spacing: 0.06em; color: #6b7280; }
    tr:hover td { background: #020617; }
    .badge { display: inline-flex; align-items: center; padding: 2px 8px; border-radius: 999px; font-size: 11px; }
    .badge.green { background: rgba(34,197,94,0.15); color: #bbf7d0; }
    .badge.red { background: rgba(248,113,113,0.15); color: #fecaca; }
    .badge.amber { background: rgba(245,158,11,0.15); color: #fed7aa; }
    .badge.gray { background: rgba(75,85,99,0.4); color: #e5e7eb; }
    .badge.person { background: rgba(59,130,246,0.15); color: #bfdbfe; }
    .badge.fraternity { background: rgba(168,85,247,0.15); color: #e9d5ff; }
    .badge.team { background: rgba(34,197,94,0.15); color: #bbf7d0; }
    .badge.business { background: rgba(245,158,11,0.15); color: #fed7aa; }
    .link { color: #38bdf8; text-decoration: none; font-weight: 500; }
    .link:hover { text-decoration: underline; }
    .group-header { background: #1e293b !important; font-weight: 600; cursor: pointer; }
    .group-header:hover { background: #2d3748 !important; }
    .group-row { background: #020617; }
    .group-row:hover { background: #1e293b; }
    .group-toggle { display: inline-block; width: 20px; text-align: center; font-weight: bold; color: #38bdf8; user-select: none; }
    .group-collapsed .group-rows { display: none; }
    .group-select-all { margin-left: auto; padding: 4px 8px; font-size: 11px; }
    .group-info { display: flex; align-items: center; gap: 8px; flex: 1; }
    .meta { display: flex; gap: 16px; font-size: 12px; color: #9ca3af; margin-bottom: 8px; }
    .meta strong { color: #e5e7eb; }
    .tabs { display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 1px solid #1f2937; }
    .tab { padding: 8px 16px; cursor: pointer; color: #9ca3af; border-bottom: 2px solid transparent; }
    .tab.active { color: #38bdf8; border-bottom-color: #38bdf8; }
    button { background: #0ea5e9; color: #0f172a; border: none; border-radius: 8px; padding: 6px 12px; font-size: 13px; font-weight: 600; cursor: pointer; }
    button:hover { background: #38bdf8; }
    button:disabled { background: #4b5563; cursor: not-allowed; opacity: 0.6; pointer-events: none; }
    button:disabled:hover { background: #4b5563; }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="card">
      <h1>RT4 Lead Console</h1>
      <div class="sub">Live state view of all current conversations and cards.</div>

      <div class="tabs">
        <div class="tab active" data-view="leads">Leads</div>
        <div class="tab" data-view="cards">Cards</div>
        <div style="flex: 1;"></div>
        <a href="upload.html" class="link" style="padding: 8px 0;">Upload Cards</a>
        <a href="markov_responses.html" class="link" style="padding: 8px 0; margin-left: 16px;">Response Editor</a>
      </div>

      <!-- Leads View -->
      <div id="leadsView">
        <div class="toolbar">
          <input id="search" placeholder="Search by name or phone">
          <select id="stateFilter">
            <option value="all">All states</option>
            <option value="active">Active (not dead/not_interested/no_time)</option>
            <option value="initial_outreach">Initial outreach only</option>
          </select>
        </div>

      <div class="pill-row">
        <div class="pill active" data-sort="state">Sort by state</div>
        <div class="pill" data-sort="name">Sort by name</div>
        <div class="pill" data-sort="folders_desc">Sort by folders</div>
      </div>

        <div class="meta" id="summary"></div>
        <div id="tableWrap"></div>
      </div>

      <!-- Cards View (Read-only, no blast) -->
      <div id="cardsView" style="display: none;">
        <div class="toolbar">
          <input id="cardSearch" placeholder="Search by name or ID">
          <select id="cardTypeFilter">
            <option value="">All types</option>
            <option value="person">Person</option>
            <option value="fraternity">Fraternity</option>
            <option value="team">Team</option>
            <option value="business">Business</option>
          </select>
          <select id="cardStateFilter">
            <option value="">All sales states</option>
            <option value="cold">Cold</option>
            <option value="qualified">Qualified</option>
            <option value="negotiating">Negotiating</option>
            <option value="won">Won</option>
            <option value="lost">Lost</option>
          </select>
          <button id="assignSelectedBtn" disabled style="background: #0ea5e9; margin-left: 8px;">Assign Selected</button>
          <button id="deleteSelectedBtn" disabled style="background: #ef4444; margin-left: 8px;">Delete Selected Cards</button>
          <div style="margin-left: auto; color: #9ca3af; font-size: 12px;">Card view - use Admin Dashboard ‚Üí Blast for blasting</div>
        </div>
        <div class="meta" id="cardSummary"></div>
        <div id="cardTableWrap"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import { BACKEND_URL } from '/config.js';
    const BACKEND = BACKEND_URL;

    // Owner-only authentication check
    (async function checkOwnerAuth() {
      const apiToken = localStorage.getItem('apiToken');
      if (!apiToken) {
        window.location.href = 'login.html';
        return;
      }

      // Verify token is owner/admin by calling admin endpoint
      try {
        const res = await fetch(`${BACKEND}/admin/users`, {
          headers: {
            'Authorization': `Bearer ${apiToken}`,
            'Content-Type': 'application/json'
          }
        });

        if (res.status === 401 || res.status === 403) {
          // Not owner/admin - redirect to login
          localStorage.removeItem('apiToken');
          window.location.href = 'login.html';
          return;
        }

        if (!res.ok) {
          // Unexpected error - redirect to login
          localStorage.removeItem('apiToken');
          window.location.href = 'login.html';
          return;
        }

        // Owner token validated - continue loading page
      } catch (error) {
        console.error('Auth check failed:', error);
        localStorage.removeItem('apiToken');
        window.location.href = 'login.html';
        return;
      }
    })();
    let allLeads = [];
    let allCards = [];
    let currentSort = "state";
    let currentView = "leads";

    function stateBadgeClass(s) {
      if (!s) return "gray";
      const v = s.toLowerCase();
      if (v.includes("ready") || v.includes("pay")) return "green";
      if (v.includes("dead") || v.includes("not_interested") || v.includes("no_time")) return "red";
      if (v.includes("question") || v.includes("who_are_you") || v.includes("waiting")) return "amber";
      if (v.includes("initial_outreach")) return "gray";
      return "amber";
    }

    function sortLeads(leads, mode) {
      if (mode === "name") {
        leads.sort((a, b) => a.name.localeCompare(b.name));
      } else if (mode === "folders_desc") {
        leads.sort((a, b) => b.folders.length - a.folders.length);
      } else {
        leads.sort((a, b) => {
          const s1 = a.latest_state?.next_state || "";
          const s2 = b.latest_state?.next_state || "";
          if (s1 === "initial_outreach" && s2 !== "initial_outreach") return 1;
          if (s2 === "initial_outreach" && s1 !== "initial_outreach") return -1;
          return s1 < s2 ? 1 : -1;
        });
      }
    }

    function render() {
      const search = document.getElementById("search").value.toLowerCase();
      const filter = document.getElementById("stateFilter").value;

      let rows = allLeads.slice();

      sortLeads(rows, currentSort);

      rows = rows.filter(l => {
        const s = l.latest_state?.next_state || "";
        if (filter === "active") {
          const v = s.toLowerCase();
          if (v.includes("dead") || v.includes("not_interested") || v.includes("no_time") || v.includes("initial_outreach")) return false;
        }
        if (filter === "initial_outreach" && s !== "initial_outreach") return false;
        if (!search) return true;
        const phone = l.folders[0]?.state?.raw?.from || l.folders[0]?.state?.contact?.phone || "";
        return l.name.toLowerCase().includes(search) || phone.toLowerCase().includes(search);
      });

      const total = allLeads.length;
      const active = allLeads.filter(l => {
        const s = l.latest_state?.next_state || "";
        const v = s.toLowerCase();
        return !(v.includes("dead") || v.includes("not_interested") || v.includes("no_time"));
      }).length;

      document.getElementById("summary").innerHTML =
        "<div><strong>" + total + "</strong> leads</div>" +
        "<div><strong>" + active + "</strong> active</div>" +
        "<div><strong>" + rows.length + "</strong> shown</div>";

      let html = "<table><thead><tr>";
      html += "<th>Name</th><th>State</th><th>Messages</th><th>Assigned To</th><th>Actions</th>";
      html += "</tr></thead><tbody>";

      rows.forEach(l => {
        const s = l.latest_state?.next_state || "";
        const cls = stateBadgeClass(s);
        const inboundCount = l.inbound_count || 0;
        const cardId = l.card_id || "";
        const assignedTo = l.assigned_to || '-';
        
        html += "<tr>";
        html += "<td>" + l.name + "</td>";
        html += "<td><span class='badge " + cls + "'>" + s + "</span></td>";
        html += "<td>" + inboundCount + " message" + (inboundCount !== 1 ? "s" : "") + "</td>";
        html += "<td>" + assignedTo + "</td>";
        html += "<td>";
        if (cardId) {
          html += "<a class='link' href='card.html?id=" + encodeURIComponent(cardId) + "' style='margin-right: 8px;'>View</a>";
        }
        if (cardId) {
          html += "<a class='link' href='#' onclick='assignLead(\"" + cardId + "\", \"" + l.name.replace(/'/g, "\\'") + "\"); return false;'>Assign</a>";
        } else {
          html += "-";
        }
        html += "</td>";
        html += "</tr>";
      });

      html += "</tbody></table>";

      document.getElementById("tableWrap").innerHTML = html;
    }

    async function load() {
      const apiToken = localStorage.getItem('apiToken');
      if (!apiToken) {
        window.location.href = 'login.html';
        return;
      }

      try {
        const res = await fetch(BACKEND + "/leads", {
          headers: {
            'Authorization': `Bearer ${apiToken}`,
            'Content-Type': 'application/json'
          }
        });
        if (res.status === 401 || res.status === 403) {
          localStorage.removeItem('apiToken');
          window.location.href = 'login.html';
          return;
        }
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        const data = await res.json();
        // Convert leads array to format expected by render function
        allLeads = (data.leads || []).map(lead => ({
          name: lead.name,
          card_id: lead.card_id,
          phone: lead.phone,
          latest_state: {
            next_state: lead.state || "unknown"
          },
          folders: [], // Not used in new system
          last_inbound_at: lead.last_inbound_at,
          last_outbound_at: lead.last_outbound_at,
          inbound_count: lead.inbound_count || 0,
          sales_state: lead.sales_state
        }));
        render();
      } catch (error) {
        console.error("Error loading leads:", error);
        document.getElementById("tableWrap").innerHTML = `<div style='color: #fecaca; padding: 20px;'>Error loading leads: ${error.message}. Make sure BACKEND URL is set correctly.</div>`;
      }
    }

    // Legacy function - deprecated (tokens should never be pasted in UI)
    function loadSavedAuthToken() {
      // No-op - auth token input removed
    }

    // Cards view functions
    async function loadCards() {
      const apiToken = localStorage.getItem('apiToken');
      if (!apiToken) {
        window.location.href = 'login.html';
        return;
      }

      try {
        const typeFilter = document.getElementById("cardTypeFilter").value;
        const stateFilter = document.getElementById("cardStateFilter").value;
        
        let url = `${BACKEND}/cards?limit=10000`;
        if (typeFilter) url += `&type=${encodeURIComponent(typeFilter)}`;
        if (stateFilter) url += `&sales_state=${encodeURIComponent(stateFilter)}`;
        
        const res = await fetch(url, {
          headers: {
            'Authorization': `Bearer ${apiToken}`,
            'Content-Type': 'application/json'
          }
        });
        if (res.status === 401 || res.status === 403) {
          localStorage.removeItem('apiToken');
          window.location.href = 'login.html';
          return;
        }
        const data = await res.json();
        allCards = data.cards || [];
        
        // Load assignments for cards
        try {
          const assignRes = await fetch(`${BACKEND}/admin/assignments`);
          if (assignRes.ok) {
            const assignData = await assignRes.json();
            const assignments = assignData.assignments || [];
            const assignmentMap = {};
            assignments.forEach(a => {
              assignmentMap[a.card_id] = a;
            });
            // Merge assignment data into cards
            allCards = allCards.map(card => ({
              ...card,
              assignment: assignmentMap[card.id]
            }));
          }
        } catch (e) {
          console.log('Could not load assignments (may need admin auth):', e);
        }
        
        renderCards();
      } catch (error) {
        document.getElementById("cardTableWrap").innerHTML = `<div style='color: #fecaca; padding: 20px;'>Error loading cards: ${error.message}</div>`;
      }
    }

    // Global selection state (source of truth)
    window.selectedCardIds = window.selectedCardIds || new Set();
    
    function getSelectedCardIds() {
      // Use state (Set) as source of truth, not DOM
      const ids = Array.from(window.selectedCardIds);
      console.log(`[SELECT] getSelectedCardIds: ${ids.length} selected cards from state:`, ids);
      return ids;
    }
    
    // DEPRECATED: Use direct Set operations in event handlers instead
    // Keeping for backward compatibility but event handlers now do this directly
    function updateSelectionState(cardId, isChecked) {
      if (!window.selectedCardIds) {
        window.selectedCardIds = new Set();
      }
      
      if (isChecked) {
        window.selectedCardIds.add(cardId);
      } else {
        window.selectedCardIds.delete(cardId);
      }
      
      console.log(`[SELECT] State updated: cardId=${cardId}, checked=${isChecked}, total=${window.selectedCardIds.size}`);
    }

    function renderCards() {
      const search = document.getElementById("cardSearch").value.toLowerCase();
      
      let rows = allCards.filter(card => {
        if (!search) return true;
        const name = card.card_data?.name || '';
        const id = card.id || '';
        return name.toLowerCase().includes(search) || id.toLowerCase().includes(search);
      });

      // Sort by updated_at desc
      rows.sort((a, b) => {
        const aTime = a.updated_at || '';
        const bTime = b.updated_at || '';
        return bTime.localeCompare(aTime);
      });

      const total = allCards.length;
      const shown = rows.length;

      document.getElementById("cardSummary").innerHTML =
        `<div><strong>${total}</strong> cards</div>` +
        `<div><strong>${shown}</strong> shown</div>`;

      // Group cards by upload batch ID (upload_batch_id) - tracks which JSON source uploaded them
      const groups = {};
      rows.forEach(card => {
        // Primary: Group by upload_batch_id (tracks which JSON upload/batch imported this card)
        const uploadBatchId = card.upload_batch_id;
        
        if (uploadBatchId) {
          // Group by upload batch ID - cards from same JSON upload will have same batch ID
          if (!groups[uploadBatchId]) {
            const importTime = card.created_at || card.updated_at || new Date().toISOString();
            groups[uploadBatchId] = {
              batchId: uploadBatchId,
              timestamp: new Date(importTime).getTime(),
              date: new Date(importTime),
              cards: [],
              hasBatchId: true
            };
          }
          groups[uploadBatchId].cards.push(card);
          return;
        }
        
        // Fallback: Group by created_at timestamp (for cards uploaded before batch tracking was added)
        const importTime = card.created_at;
        if (!importTime) {
          const fallbackTime = card.updated_at || new Date().toISOString();
          const date = new Date(fallbackTime);
          const timestamp = Math.floor(date.getTime() / 5000) * 5000;
          const instanceKey = `fallback-${timestamp}`;
          
          if (!groups[instanceKey]) {
            groups[instanceKey] = {
              batchId: null,
              timestamp: timestamp,
              date: date,
              cards: [],
              hasBatchId: false
            };
          }
          groups[instanceKey].cards.push(card);
          return;
        }
        
        const date = new Date(importTime);
        // Round to nearest 5 seconds for grouping
        const timestamp = Math.floor(date.getTime() / 5000) * 5000;
        const instanceKey = `timestamp-${timestamp}`;
        
        if (!groups[instanceKey]) {
          groups[instanceKey] = {
            batchId: null,
            timestamp: timestamp,
            date: date,
            cards: [],
            hasBatchId: false
          };
        }
        groups[instanceKey].cards.push(card);
      });

      // Sort groups by timestamp (newest first)
      const sortedGroups = Object.keys(groups).sort((a, b) => {
        return groups[b].timestamp - groups[a].timestamp;
      });

      let html = "<table><thead><tr>";
      html += "<th><input type='checkbox' id='selectAllCheckbox' title='Select all cards'></th><th>Name</th><th>Type</th><th>Sales State</th><th>Assigned To</th><th>Updated</th><th>Actions</th>";
      html += "</tr></thead><tbody>";

      sortedGroups.forEach(instanceKey => {
        const group = groups[instanceKey];
        const groupCards = group.cards;
        const groupId = `group-${instanceKey}`;
        const dateStr = group.date.toLocaleString();
        
        // Group header row - collapsible
        html += `<tr class="group-header" data-group-id="${groupId}" onclick="toggleGroup('${groupId}')" style="background: #1e293b; font-weight: 600; cursor: pointer;">`;
        html += `<td style="position: relative;" onclick="event.stopPropagation();">`;
        html += `<input type="checkbox" class="group-checkbox" data-group-id="${groupId}" onclick="event.stopPropagation();">`;
        html += `</td>`;
        html += `<td colspan="5" style="padding: 12px 6px;">`;
        html += `<div style="display: flex; align-items: center; gap: 8px;">`;
        html += `<span class="group-toggle" id="toggle-${groupId}" style="display: inline-block; width: 20px; text-align: center; font-weight: bold; color: #38bdf8; user-select: none;">‚ñº</span>`;
        if (group.hasBatchId && group.batchId) {
          html += `<span>üì¶ Source: <strong>${group.batchId}</strong> | Imported: ${dateStr} (${groupCards.length} card${groupCards.length !== 1 ? 's' : ''})</span>`;
        } else {
          html += `<span>üì¶ Imported: ${dateStr} (${groupCards.length} card${groupCards.length !== 1 ? 's' : ''})</span>`;
        }
        html += `</div>`;
        html += `</td>`;
        html += `<td style="text-align: right; padding: 12px 6px;" onclick="event.stopPropagation();">`;
        html += `<button class="group-select-all" onclick="event.stopPropagation(); selectGroup('${groupId}'); return false;" style="padding: 4px 8px; font-size: 11px; background: #0ea5e9; color: #0f172a; border: none; border-radius: 4px; cursor: pointer;">Select All</button>`;
        html += `</td>`;
        html += '</tr>';

        // Cards in this group
        groupCards.forEach(card => {
          const name = card.card_data?.name || card.id;
          const type = card.type || 'person';
          const salesState = card.sales_state || 'cold';
          const assignedTo = card.assignment?.username || card.assignment?.user_id || '-';
          const updated = card.updated_at ? new Date(card.updated_at).toLocaleDateString() : '-';
          
          html += `<tr class="group-row group-rows" data-group-id="${groupId}">`;
          html += `<td><input type="checkbox" class="card-select-checkbox" data-id="${card.id}" data-group-id="${groupId}"></td>`;
          html += `<td>${name}</td>`;
          html += `<td><span class='badge ${type}'>${type}</span></td>`;
          html += `<td><span class='badge gray'>${salesState}</span></td>`;
          html += `<td>${assignedTo}</td>`;
          html += `<td>${updated}</td>`;
          html += `<td><a class='link' href='card.html?id=${encodeURIComponent(card.id)}' style='margin-right: 8px;'>View</a>`;
          html += `<a class='link' href='#' onclick='assignCard("${card.id}"); return false;' style='margin-right: 8px;'>Assign</a>`;
          html += `<a class='link' href='#' onclick='deleteCard("${card.id}"); return false;' style='color: #fecaca;'>Delete</a></td>`;
          html += "</tr>";
        });
      });

      html += "</tbody></table>";
      document.getElementById("cardTableWrap").innerHTML = html;

      // Select all checkbox functionality
      const selectAllCheckbox = document.getElementById("selectAllCheckbox");
      // Query checkboxes fresh each time (they may be in collapsed groups)
      let cardCheckboxes = document.querySelectorAll(".card-select-checkbox");
      
      console.log(`[CHECKBOX] Found ${cardCheckboxes.length} checkboxes after render`);
      
      if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener("change", (e) => {
          const isChecked = e.target.checked;
          console.log(`[CHECKBOX] Select all: ${isChecked}`);
          // Query fresh - checkboxes might be in collapsed groups
          const allCheckboxes = document.querySelectorAll(".card-select-checkbox");
          allCheckboxes.forEach(cb => {
            cb.checked = isChecked;
            const cardId = cb.getAttribute('data-id') || cb.dataset.id || cb.dataset.cardId;
            if (cardId) {
              // Directly update state (don't rely on change event for programmatic changes)
              if (!window.selectedCardIds) {
                window.selectedCardIds = new Set();
              }
              if (isChecked) {
                window.selectedCardIds.add(cardId);
              } else {
                window.selectedCardIds.delete(cardId);
              }
              console.log('[SELECT] Select All: Updated cardId', cardId, 'checked=', isChecked, 'Set size:', window.selectedCardIds.size);
            } else {
              console.error('[SELECT] Select All: Checkbox missing data-id!', cb);
            }
          });
          // Update group checkboxes
          document.querySelectorAll('.group-checkbox').forEach(gcb => {
            gcb.checked = isChecked;
          });
          updateBlastButtonState();
          if (window.updateAssignButtonState) window.updateAssignButtonState();
        });
      }

      // Group checkbox functionality
      document.querySelectorAll('.group-checkbox').forEach(gcb => {
        gcb.addEventListener('change', (e) => {
          e.stopPropagation();
          const groupId = e.target.getAttribute('data-group-id');
          const checked = e.target.checked;
          console.log(`[CHECKBOX] Group ${groupId}: ${checked}`);
          // Query fresh for this group
          const groupCheckboxes = document.querySelectorAll(`.card-select-checkbox[data-group-id="${groupId}"]`);
          console.log(`[CHECKBOX] Found ${groupCheckboxes.length} checkboxes in group ${groupId}`);
          groupCheckboxes.forEach(cb => {
            cb.checked = checked;
            const cardId = cb.getAttribute('data-id') || cb.dataset.id || cb.dataset.cardId;
            if (cardId) {
              // Directly update state (don't rely on change event for programmatic changes)
              if (!window.selectedCardIds) {
                window.selectedCardIds = new Set();
              }
              if (checked) {
                window.selectedCardIds.add(cardId);
              } else {
                window.selectedCardIds.delete(cardId);
              }
              console.log('[SELECT] Group Select: Updated cardId', cardId, 'checked=', checked, 'Set size:', window.selectedCardIds.size);
            } else {
              console.error('[SELECT] Group Select: Checkbox missing data-id!', cb);
            }
          });
          updateBlastButtonState();
          if (window.updateAssignButtonState) window.updateAssignButtonState();
        });
      });

      // BULLETPROOF: Use multiple event listeners to ensure we catch all checkbox changes
      // Listen for both 'change' and 'click' events on checkboxes
      if (!window.cardCheckboxDelegateAttached) {
        // CRITICAL: Global checkbox handler - THE BRIDGE THAT CONNECTS DOM TO STATE
        // This is the ONLY place that mutates window.selectedCardIds
        document.addEventListener('change', function(e) {
          const cb = e.target;
          
          // Only handle card checkboxes
          if (cb.type !== 'checkbox' || !cb.classList.contains('card-select-checkbox')) {
            return;
          }
          
          // Get card ID - CRITICAL: must exist or nothing works
          const cardId = cb.getAttribute('data-id') || cb.dataset.id || cb.dataset.cardId;
          
          if (!cardId) {
            console.error('[SELECT] ‚ùå CRITICAL: Checkbox missing data-id attribute!', cb);
            console.error('[SELECT] Checkbox attributes:', {
              id: cb.id,
              className: cb.className,
              dataset: cb.dataset,
              attributes: Array.from(cb.attributes).map(a => `${a.name}="${a.value}"`).join(', ')
            });
            return;
          }
          
          const isChecked = cb.checked;
          
          console.log('[SELECT] ‚úÖ Checkbox changed:', { cardId, isChecked, checkbox: cb });
          
          // CRITICAL: Update state (this is the missing bridge)
          if (!window.selectedCardIds) {
            window.selectedCardIds = new Set();
          }
          
          if (isChecked) {
            window.selectedCardIds.add(cardId);
            console.log('[SELECT] ‚ûï Added cardId to Set:', cardId, 'Size now:', window.selectedCardIds.size);
          } else {
            window.selectedCardIds.delete(cardId);
            console.log('[SELECT] ‚ûñ Removed cardId from Set:', cardId, 'Size now:', window.selectedCardIds.size);
          }
          
          console.log('[SELECT] üìä Current Set:', Array.from(window.selectedCardIds));
          
          // Update button based on state
          if (window.updateAssignButtonState) {
            window.updateAssignButtonState();
          } else {
            console.error('[SELECT] ‚ùå updateAssignButtonState not found!');
          }
          
          // Also update other UI elements
          if (typeof updateBlastButtonState === 'function') updateBlastButtonState();
          if (typeof updateGroupCheckboxState === 'function') updateGroupCheckboxState(cb);
        }, true);
        
        // Backup click handler (in case change doesn't fire)
        document.addEventListener('click', function(e) {
          const cb = e.target;
          
          if (cb.type !== 'checkbox' || !cb.classList.contains('card-select-checkbox')) {
            return;
          }
          
          // Use setTimeout to let browser update checked state first
          setTimeout(() => {
            const cardId = cb.getAttribute('data-id') || cb.dataset.id || cb.dataset.cardId;
            
            if (!cardId) {
              console.error('[SELECT] ‚ùå CLICK: Checkbox missing data-id!', cb);
              return;
            }
            
            const isChecked = cb.checked;
            
            console.log('[SELECT] ‚úÖ CLICK EVENT (backup):', { cardId, isChecked });
            
            // Update state
            if (!window.selectedCardIds) {
              window.selectedCardIds = new Set();
            }
            
            if (isChecked) {
              window.selectedCardIds.add(cardId);
            } else {
              window.selectedCardIds.delete(cardId);
            }
            
            console.log('[SELECT] üìä CLICK: Set after update:', Array.from(window.selectedCardIds));
            
            if (window.updateAssignButtonState) {
              window.updateAssignButtonState();
            }
            
            if (typeof updateBlastButtonState === 'function') updateBlastButtonState();
            if (typeof updateGroupCheckboxState === 'function') updateGroupCheckboxState(cb);
          }, 0);
        }, true);
        
        window.cardCheckboxDelegateAttached = true;
        console.log('[CHECKBOX] Event listeners attached (change + click)');
      }
      
      console.log(`[CHECKBOX] Found ${cardCheckboxes.length} checkboxes in table`);

      // Update group checkbox state when individual checkboxes change
      function updateGroupCheckboxState(cardCheckbox) {
        const groupId = cardCheckbox.getAttribute('data-group-id');
        const groupCheckbox = document.querySelector(`.group-checkbox[data-group-id="${groupId}"]`);
        if (groupCheckbox) {
          const groupCards = document.querySelectorAll(`.card-select-checkbox[data-group-id="${groupId}"]`);
          const allChecked = Array.from(groupCards).every(cb => cb.checked);
          const someChecked = Array.from(groupCards).some(cb => cb.checked);
          groupCheckbox.checked = allChecked;
          groupCheckbox.indeterminate = someChecked && !allChecked;
        }
      }

      // BULLETPROOF: Derive state from checked checkboxes (visual state, not internal model)
      // Count checkboxes that are actually checked in the DOM
      window.updateAssignButtonState = function() {
        const btn = document.getElementById('assignSelectedBtn');
        if (!btn) {
          console.error('[ASSIGN] Button not found!');
          return;
        }
        
        // OPTION B: Count checked checkboxes directly from DOM (they ARE the source of truth)
        // This works because checkboxes maintain their checked state even after re-renders
        const checkedCheckboxes = document.querySelectorAll('.card-select-checkbox:checked');
        const count = checkedCheckboxes.length;
        
        // Also sync to Set for getSelectedCardIds() compatibility
        if (window.selectedCardIds) {
          window.selectedCardIds.clear();
          checkedCheckboxes.forEach(cb => {
            const cardId = cb.getAttribute('data-id') || cb.dataset.id || cb.dataset.cardId;
            if (cardId) {
              window.selectedCardIds.add(cardId);
            }
          });
        }
        
        console.log('[ASSIGN] Checked checkboxes count =', count);
        console.log('[ASSIGN] Selected card IDs:', Array.from(window.selectedCardIds || []));
        
        if (count > 0) {
          // ENABLE: Remove ALL ways it can be disabled
          btn.disabled = false;
          btn.removeAttribute('disabled');
          btn.style.pointerEvents = 'auto';
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          console.log('[ASSIGN] ‚úÖ BUTTON ENABLED (', count, 'cards selected)');
        } else {
          // DISABLE
          btn.disabled = true;
          btn.setAttribute('disabled', 'disabled');
          btn.style.pointerEvents = 'none';
          btn.style.opacity = '0.6';
          btn.style.cursor = 'not-allowed';
          console.log('[ASSIGN] ‚ùå BUTTON DISABLED (no cards selected)');
        }
      };
      
      // Legacy function name for compatibility
      window.updateSelectAllState = window.updateAssignButtonState;

      // Clear selection state when re-rendering (cards may have changed)
      window.selectedCardIds = new Set();
      
      // Initial button state
      if (window.updateAssignButtonState) window.updateAssignButtonState();
      
      // Re-attach assign button listener (button is in toolbar, shouldn't be recreated, but ensure it's attached)
      if (window.assignSelectedCards) {
        const assignBtn = document.getElementById("assignSelectedBtn");
        if (assignBtn && !assignBtn.hasAttribute('data-listener-attached')) {
          assignBtn.addEventListener("click", window.assignSelectedCards);
          assignBtn.setAttribute('data-listener-attached', 'true');
          console.log('[ASSIGN] Event listener attached after render');
        }
      }
    }

    // Legacy blast functionality removed - use Admin Dashboard ‚Üí Blast instead

    // Tab switching
    document.querySelectorAll(".tab").forEach(tab => {
      tab.addEventListener("click", () => {
        const view = tab.getAttribute("data-view");
        currentView = view;
        
        document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
        tab.classList.add("active");
        
        document.getElementById("leadsView").style.display = view === "leads" ? "block" : "none";
        document.getElementById("cardsView").style.display = view === "cards" ? "block" : "none";
        
        if (view === "cards") {
          loadCards();
        }
      });
    });

    document.getElementById("search").addEventListener("input", render);
    document.getElementById("stateFilter").addEventListener("change", render);
    async function deleteCard(cardId) {
      if (!confirm(`Delete card "${cardId}"? This will also delete related conversations and relationships.`)) {
        return;
      }

      try {
        const res = await fetch(`${BACKEND}/cards/${encodeURIComponent(cardId)}`, {
          method: "DELETE",
        });

        if (!res.ok) {
          const data = await res.json();
          alert(`Delete failed: ${data.detail || res.status}`);
          return;
        }

        alert("Card deleted successfully");
        loadCards(); // Refresh the list
      } catch (error) {
        alert(`Delete error: ${error.message}`);
      }
    }

    // Expose deleteCard to global scope for inline onclick
    window.deleteCard = deleteCard;
    
    async function assignCard(cardId) {
      // Get list of users for assignment
      const apiToken = localStorage.getItem('apiToken');
      if (!apiToken) {
        alert('Please login as admin to assign cards');
        window.location.href = 'login.html';
        return;
      }
      
      try {
        const res = await fetch(`${BACKEND}/admin/users`, {
          headers: {
            'Authorization': `Bearer ${apiToken}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (res.status === 401 || res.status === 403) {
          alert('Admin access required');
          return;
        }
        
        const data = await res.json();
        const users = data.users || [];
        
        if (users.length === 0) {
          alert('No users found. Create a user first in the admin dashboard.');
          return;
        }
        
        const userOptions = users.map(u => `${u.id}:${u.username}`).join('\n');
        const selection = prompt(`Assign card to user:\n\n${users.map((u, i) => `${i + 1}. ${u.username} (${u.id})`).join('\n')}\n\nEnter username or ID:`);
        
        if (!selection) return;
        
        // Find user by username or ID
        const user = users.find(u => u.username.toLowerCase() === selection.toLowerCase() || u.id.toLowerCase() === selection.toLowerCase());
        if (!user) {
          alert('User not found');
          return;
        }
        
        const notes = prompt('Assignment notes (optional):') || null;
        
        const assignRes = await fetch(`${BACKEND}/admin/assignments`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            card_id: cardId,
            user_id: user.id,
            notes: notes
          })
        });
        
        const assignData = await assignRes.json();
        if (assignData.ok) {
          alert(`Card assigned to ${user.username} successfully`);
          loadCards();
        } else {
          alert(`Failed to assign: ${assignData.detail || 'Unknown error'}`);
        }
      } catch (error) {
        alert(`Error: ${error.message}`);
      }
    }
    
    window.assignCard = assignCard;

    document.getElementById("cardSearch").addEventListener("input", renderCards);

    // Toggle group collapse/expand (global for onclick)
    window.toggleGroup = function(groupId) {
      const rows = document.querySelectorAll(`tr.group-row.group-rows[data-group-id="${groupId}"]`);
      const toggle = document.getElementById(`toggle-${groupId}`);
      const header = document.querySelector(`.group-header[data-group-id="${groupId}"]`);
      
      if (rows.length > 0) {
        const isCollapsed = rows[0].style.display === 'none';
        rows.forEach(row => {
          row.style.display = isCollapsed ? '' : 'none';
        });
        if (toggle) {
          toggle.textContent = isCollapsed ? '‚ñº' : '‚ñ∂';
        }
        if (header) {
          header.classList.toggle('group-collapsed', !isCollapsed);
        }
      }
    };

    // Select all cards in a group (global for onclick)
    window.selectGroup = function(groupId) {
      const checkboxes = document.querySelectorAll(`.card-select-checkbox[data-group-id="${groupId}"]`);
      const groupCheckbox = document.querySelector(`.group-checkbox[data-group-id="${groupId}"]`);
      
      // Check if all are already checked
      const allChecked = Array.from(checkboxes).every(cb => cb.checked);
      const newCheckedState = !allChecked;
      
      // Toggle all and update state
      checkboxes.forEach(cb => {
        cb.checked = newCheckedState;
        const cardId = cb.getAttribute('data-id') || cb.dataset.id || cb.dataset.cardId;
        if (cardId) {
          // Directly update state (don't rely on change event for programmatic changes)
          if (!window.selectedCardIds) {
            window.selectedCardIds = new Set();
          }
          if (newCheckedState) {
            window.selectedCardIds.add(cardId);
          } else {
            window.selectedCardIds.delete(cardId);
          }
          console.log('[SELECT] selectGroup: Updated cardId', cardId, 'checked=', newCheckedState, 'Set size:', window.selectedCardIds.size);
        } else {
          console.error('[SELECT] selectGroup: Checkbox missing data-id!', cb);
        }
      });
      
      if (groupCheckbox) {
        groupCheckbox.checked = newCheckedState;
      }
      
      updateBlastButtonState();
      if (window.updateAssignButtonState) window.updateAssignButtonState();
    };
    document.getElementById("cardTypeFilter").addEventListener("change", loadCards);
    document.getElementById("cardStateFilter").addEventListener("change", loadCards);
    
    async function deleteSelectedCards() {
      const selectedIds = getSelectedCardIds();
      if (selectedIds.length === 0) {
        alert("No cards selected");
        return;
      }

      const count = selectedIds.length;
      if (!confirm(`Delete ${count} card(s)? This will also delete related conversations and relationships. This action cannot be undone.`)) {
        return;
      }

      const deleteBtn = document.getElementById("deleteSelectedBtn");
      deleteBtn.disabled = true;
      deleteBtn.textContent = "Deleting...";

      try {
        let successCount = 0;
        let failCount = 0;
        const errors = [];

        // Delete cards one by one (could be optimized with a bulk endpoint)
        for (const cardId of selectedIds) {
          try {
            const res = await fetch(`${BACKEND}/cards/${encodeURIComponent(cardId)}`, {
              method: "DELETE",
            });

            if (!res.ok) {
              const data = await res.json();
              errors.push(`${cardId}: ${data.detail || res.status}`);
              failCount++;
            } else {
              successCount++;
            }
          } catch (error) {
            errors.push(`${cardId}: ${error.message}`);
            failCount++;
          }
        }

        if (failCount > 0) {
          alert(`Delete completed with errors.\n\nDeleted: ${successCount}\nFailed: ${failCount}\n\nErrors:\n${errors.slice(0, 5).join('\n')}${errors.length > 5 ? '\n...' : ''}`);
        } else {
          alert(`Successfully deleted ${successCount} card(s).`);
        }

        // Refresh the list
        loadCards();
      } catch (error) {
        alert(`Delete error: ${error.message}`);
      } finally {
        deleteBtn.disabled = false;
        deleteBtn.textContent = "Delete Selected Cards";
      }
    }

    document.getElementById("deleteSelectedBtn").addEventListener("click", deleteSelectedCards);
    
    // Assign selected cards
    async function assignSelectedCards() {
      console.log('[ASSIGN] assignSelectedCards called');
      const selected = getSelectedCardIds();
      console.log('[ASSIGN] Selected cards:', selected);
      
      if (selected.length === 0) {
        alert('No cards selected');
        return;
      }
      
      const apiToken = localStorage.getItem('apiToken');
      if (!apiToken) {
        alert('Please login as admin to assign cards');
        window.location.href = 'login.html';
        return;
      }
      
      const assignBtn = document.getElementById("assignSelectedBtn");
      if (!assignBtn) {
        console.error('[ASSIGN] Button not found!');
        alert('Error: Assign button not found');
        return;
      }
      
      try {
        console.log('[ASSIGN] Fetching users...');
        // Get list of users for assignment
        const res = await fetch(`${BACKEND}/admin/users`, {
          headers: {
            'Authorization': `Bearer ${apiToken}`,
            'Content-Type': 'application/json'
          }
        });
        
        console.log('[ASSIGN] Users response status:', res.status);
        
        if (res.status === 401 || res.status === 403) {
          alert('Admin access required');
          return;
        }
        
        if (!res.ok) {
          const errorText = await res.text();
          console.error('[ASSIGN] Users fetch error:', errorText);
          alert(`Error fetching users: ${res.status} - ${errorText}`);
          return;
        }
        
        const data = await res.json();
        console.log('[ASSIGN] Users data:', data);
        const users = data.users || [];
        
        if (users.length === 0) {
          alert('No users found. Create a user first in the admin dashboard.');
          return;
        }
        
        const userOptions = users.map((u, i) => `${i + 1}. ${u.username} (${u.id})`).join('\n');
        const selection = prompt(`Assign ${selected.length} card(s) to user:\n\n${userOptions}\n\nEnter username or ID:`);
        
        if (!selection) {
          console.log('[ASSIGN] User cancelled selection');
          return;
        }
        
        // Find user by username or ID
        const user = users.find(u => u.username.toLowerCase() === selection.toLowerCase() || u.id.toLowerCase() === selection.toLowerCase());
        if (!user) {
          alert(`User not found: "${selection}"`);
          return;
        }
        
        console.log('[ASSIGN] Selected user:', user);
        
        const notes = prompt('Assignment notes (optional):') || null;
        
        assignBtn.disabled = true;
        assignBtn.textContent = `Assigning ${selected.length} card(s)...`;
        
        let successCount = 0;
        let failCount = 0;
        const errors = [];
        
        console.log('[ASSIGN] Starting assignment of', selected.length, 'cards');
        
        // Assign each card
        for (let i = 0; i < selected.length; i++) {
          const cardId = selected[i];
          console.log(`[ASSIGN] Assigning card ${i + 1}/${selected.length}: ${cardId}`);
          
          try {
            const assignRes = await fetch(`${BACKEND}/admin/assignments`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${apiToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                card_id: cardId,
                user_id: user.id,
                notes: notes
              })
            });
            
            console.log(`[ASSIGN] Assignment response for ${cardId}:`, assignRes.status);
            
            if (!assignRes.ok) {
              const errorText = await assignRes.text();
              console.error(`[ASSIGN] Assignment failed for ${cardId}:`, errorText);
              let errorDetail = 'Unknown error';
              try {
                const errorData = JSON.parse(errorText);
                errorDetail = errorData.detail || errorText;
              } catch {
                errorDetail = errorText;
              }
              failCount++;
              errors.push(`${cardId}: ${errorDetail}`);
              continue;
            }
            
            const assignData = await assignRes.json();
            console.log(`[ASSIGN] Assignment data for ${cardId}:`, assignData);
            
            if (assignData.ok) {
              successCount++;
              console.log(`[ASSIGN] ‚úÖ Successfully assigned ${cardId}`);
            } else {
              failCount++;
              errors.push(`${cardId}: ${assignData.detail || 'Assignment failed'}`);
              console.error(`[ASSIGN] ‚ùå Assignment failed for ${cardId}:`, assignData);
            }
          } catch (error) {
            console.error(`[ASSIGN] Exception assigning ${cardId}:`, error);
            failCount++;
            errors.push(`${cardId}: ${error.message}`);
          }
        }
        
        assignBtn.disabled = false;
        assignBtn.textContent = "Assign Selected";
        
        console.log(`[ASSIGN] Complete: ${successCount} success, ${failCount} failed`);
        
        // Show detailed feedback
        if (failCount === 0 && successCount > 0) {
          alert(`‚úÖ Successfully assigned ${successCount} card(s) to ${user.username}`);
        } else if (successCount > 0 && failCount > 0) {
          alert(`‚ö†Ô∏è Partially completed:\n\n‚úÖ Assigned: ${successCount} card(s)\n‚ùå Failed: ${failCount} card(s)\n\nErrors:\n${errors.slice(0, 5).join('\n')}${errors.length > 5 ? '\n...' : ''}`);
        } else if (failCount > 0) {
          alert(`‚ùå Assignment failed for all ${failCount} card(s):\n\n${errors.slice(0, 5).join('\n')}${errors.length > 5 ? '\n...' : ''}`);
        } else {
          alert('No cards were assigned. Please check the console for details.');
        }
        
        loadCards();
      } catch (error) {
        console.error('[ASSIGN] Exception:', error);
        assignBtn.disabled = false;
        assignBtn.textContent = "Assign Selected";
        alert(`‚ùå Error: ${error.message}\n\nCheck console for details.`);
      }
    }
    
    // Make function globally accessible
    window.assignSelectedCards = assignSelectedCards;
    
    // Use event delegation on document body - this always works
    // This catches clicks even if button is recreated or listeners fail
    document.body.addEventListener('click', function(e) {
      const target = e.target;
      const btn = target.id === 'assignSelectedBtn' ? target : target.closest('#assignSelectedBtn');
      
      if (btn) {
        console.log('[ASSIGN] üîµ Button clicked via event delegation');
        console.log('[ASSIGN] Button disabled state:', btn.disabled);
        console.log('[ASSIGN] Button hasAttribute disabled:', btn.hasAttribute('disabled'));
        console.log('[ASSIGN] Button computed style pointerEvents:', getComputedStyle(btn).pointerEvents);
        
        // Check current selection count
        const currentSelected = document.querySelectorAll('.card-select-checkbox:checked').length;
        console.log('[ASSIGN] Current selected count:', currentSelected);
        
        // If disabled, check if it should actually be enabled
        if (btn.disabled && currentSelected > 0) {
          console.log('[ASSIGN] ‚ö†Ô∏è Button is disabled but cards are selected - enabling and continuing');
          btn.removeAttribute('disabled');
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          btn.style.pointerEvents = 'auto';
          // Don't return - continue to call the function
        } else if (btn.disabled && currentSelected === 0) {
          console.log('[ASSIGN] ‚ö†Ô∏è Button is disabled and no cards selected');
          alert('Please select at least one card to assign.');
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        
        // Call the function
        console.log('[ASSIGN] Calling assignSelectedCards function...');
        if (window.assignSelectedCards) {
          try {
            window.assignSelectedCards();
          } catch (err) {
            console.error('[ASSIGN] Error calling function:', err);
            alert(`Error: ${err.message}`);
          }
        } else {
          console.error('[ASSIGN] assignSelectedCards function not found!');
          alert('Error: Assign function not available');
        }
        
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }, true); // Use capture phase for better reliability
    
    // Also try direct attachment as backup
    function attachAssignListener() {
      const assignBtn = document.getElementById("assignSelectedBtn");
      if (assignBtn) {
        // Remove old listeners and add new one
        const newBtn = assignBtn.cloneNode(true);
        assignBtn.parentNode.replaceChild(newBtn, assignBtn);
        newBtn.addEventListener("click", function(e) {
          e.preventDefault();
          e.stopPropagation();
          console.log('[ASSIGN] Button clicked via direct listener');
          if (window.assignSelectedCards) {
            window.assignSelectedCards();
          }
          return false;
        });
        console.log('[ASSIGN] ‚úÖ Direct event listener attached to button');
        return true;
      }
      return false;
    }
    
    // Try to attach immediately and on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', attachAssignListener);
    } else {
      attachAssignListener();
    }
    
    // Also try after a delay as fallback
    setTimeout(attachAssignListener, 500);

    document.querySelectorAll(".pill").forEach(p => {
      p.addEventListener("click", () => {
        document.querySelectorAll(".pill").forEach(x => x.classList.remove("active"));
        p.classList.add("active");
        currentSort = p.getAttribute("data-sort");
        render();
      });
    });

    load();
    // Load saved auth token on initial page load
    loadSavedAuthToken();
    // Auto-refresh every 30 seconds
    setInterval(() => {
      if (currentView === "leads") {
        load();
      } else {
        loadCards();
      }
    }, 30000);
  </script>
</body>
</html>
