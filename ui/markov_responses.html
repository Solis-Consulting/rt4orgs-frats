<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Markov Response Editor - RT4 CRM</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 0; background: #0f172a; color: #e5e7eb; }
    .shell { max-width: 1200px; margin: 32px auto; padding: 0 16px; }
    .card { background: #020617; border-radius: 16px; padding: 20px 24px; box-shadow: 0 18px 60px rgba(0,0,0,0.6); border: 1px solid #1f2937; margin-bottom: 16px; }
    h1 { margin: 0 0 8px; font-size: 24px; }
    .sub { margin-bottom: 16px; color: #9ca3af; font-size: 14px; }
    .link { color: #38bdf8; text-decoration: none; font-weight: 500; }
    .link:hover { text-decoration: underline; }
    .section { margin-top: 24px; border-top: 1px solid #1f2937; padding-top: 16px; }
    .section-title { font-size: 18px; margin-bottom: 12px; color: #e5e7eb; }
    textarea { width: 100%; min-height: 100px; background: #020617; border: 1px solid #4b5563; border-radius: 8px; padding: 12px; color: #e5e7eb; font-family: 'Monaco', 'Courier New', monospace; font-size: 13px; }
    textarea:focus { outline: none; border-color: #38bdf8; }
    button { background: #0ea5e9; color: #0f172a; border: none; border-radius: 8px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; margin-right: 8px; }
    button:hover { background: #38bdf8; }
    button:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
    .button-secondary { background: #374151; color: #e5e7eb; }
    .button-secondary:hover { background: #4b5563; }
    .success { background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.3); color: #bbf7d0; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .error { background: rgba(248,113,113,0.15); border: 1px solid rgba(248,113,113,0.3); color: #fecaca; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .state-row { margin-bottom: 16px; padding: 12px; background: #111827; border-radius: 8px; border: 1px solid #1f2937; }
    .state-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .state-key { font-family: monospace; font-size: 12px; color: #9ca3af; }
    .state-badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-left: 8px; }
    .state-description { font-size: 11px; color: #6b7280; margin-bottom: 8px; }
    .state-actions { display: flex; gap: 8px; margin-top: 8px; }
    .save-state-btn { background: #0ea5e9; color: #0f172a; border: none; border-radius: 6px; padding: 6px 12px; font-size: 12px; font-weight: 600; cursor: pointer; }
    .save-state-btn:hover { background: #38bdf8; }
    .save-state-btn:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
    .save-state-btn.saved { background: #22c55e; color: white; }
    @keyframes flashSaved { 0% { background: #22c55e; } 100% { background: #0ea5e9; } }
    .response-input { width: 100%; min-height: 60px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; margin-top: 8px; }
    th, td { padding: 8px 6px; text-align: left; border-bottom: 1px solid #1f2937; }
    th { font-size: 11px; text-transform: uppercase; letter-spacing: 0.06em; color: #6b7280; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="card">
      <a href="index.html" class="link">&larr; Back to list</a>
      <h1>Markov Response Editor</h1>
      <div class="sub">Configure auto-responses for each Markov state and the initial outreach message.</div>

      <div id="status"></div>

      <!-- Initial Outreach Section -->
      <div class="section">
        <div class="section-title">Initial Outreach Message</div>
        <div style="margin-bottom: 8px; font-size: 12px; color: #9ca3af;">
          This message is sent during outbound blasts. Supports placeholders: {"{"}name{"}"}, {"{"}fraternity{"}"}
        </div>
        <textarea id="initialOutreach" placeholder="Hello {name}, we would like to know how {fraternity}'s spring rush could be with a FRESH PNM list..."></textarea>
        <div class="state-actions">
          <button class="save-state-btn" id="saveInitialOutreachBtn" onclick="saveState('__initial_outreach__', 'initialOutreach', 'saveInitialOutreachBtn')">Save</button>
        </div>
      </div>

      <!-- State Responses Section -->
      <div class="section">
        <div class="section-title">State Responses</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Configure the auto-reply message for each Markov state. Leave empty to skip replies for that state.
        </div>
        <div id="stateResponses"></div>
      </div>

      <!-- JSON Import Section -->
      <div class="section">
        <div class="section-title">JSON Import</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Paste JSON to populate all fields. Import automatically saves to backend.
        </div>
        <textarea id="jsonInput" placeholder='{"initial_outreach": "...", "responses": {"state_key": {"response_text": "...", "description": "..."}}}' style="min-height: 150px; font-family: 'Monaco', 'Courier New', monospace; font-size: 12px;"></textarea>
        <div style="margin-top: 12px;">
          <button id="importBtn" onclick="importFromJSON()">Import JSON</button>
        </div>
      </div>

      <div style="margin-top: 24px;">
        <button class="button-secondary" onclick="loadResponses()" style="opacity: 0.7;">Reload</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { BACKEND_URL } from '/config.js';
    const BACKEND = BACKEND_URL;
    
    // Log backend URL on load for debugging
    console.log('Markov Response Editor initialized');
    console.log('BACKEND_URL from config:', BACKEND_URL);
    console.log('BACKEND constant:', BACKEND);
    console.log('Location:', window.location.href);

    // States will be loaded from the registry endpoint
    let MARKOV_STATES = [];

    function showStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.className = type;
      statusDiv.textContent = message;
      statusDiv.style.display = 'block';
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 5000);
    }

    async function loadResponses() {
      try {
        console.log('LOAD: BACKEND URL =', BACKEND);
        
        // Step 1: Fetch all states from the registry (authoritative source)
        const statesUrl = `${BACKEND}/markov/states`;
        console.log('LOAD: Fetching states from', statesUrl);
        const statesRes = await fetch(statesUrl);
        console.log('LOAD: States response status =', statesRes.status);
        if (!statesRes.ok) {
          throw new Error(`Failed to load states: ${statesRes.status}`);
        }
        MARKOV_STATES = await statesRes.json();
        console.log('LOAD: Loaded', MARKOV_STATES.length, 'states');

        // Step 2: Fetch configured responses from DB
        const responsesUrl = `${BACKEND}/markov/responses`;
        console.log('LOAD: Fetching responses from', responsesUrl);
        const responsesRes = await fetch(responsesUrl);
        console.log('LOAD: Responses response status =', responsesRes.status);
        if (!responsesRes.ok) {
          throw new Error(`Failed to load responses: ${responsesRes.status}`);
        }
        const responsesData = await responsesRes.json();
        console.log('LOAD: Loaded responses data', Object.keys(responsesData.responses || {}).length, 'configured states');

        // Load initial outreach
        if (responsesData.initial_outreach) {
          document.getElementById('initialOutreach').value = responsesData.initial_outreach;
        }

        // Step 3: Merge states (registry) with responses (config)
        const responses = responsesData.responses || {};
        const container = document.getElementById('stateResponses');
        container.innerHTML = '';

        MARKOV_STATES.forEach(state => {
          // Get config for this state (if it exists)
          const stateConfig = responses[state.state_key] || {};
          const responseText = stateConfig.response_text || '';
          const configDescription = stateConfig.description || '';
          
          // Use description from registry, or fallback to config description
          const description = state.description || configDescription || '';

          const row = document.createElement('div');
          row.className = 'state-row';
          const textareaId = `state-${state.state_key}`;
          const buttonId = `save-${state.state_key}-btn`;
          row.innerHTML = `
            <div class="state-header">
              <div>
                <strong>${state.label || state.state_key}</strong>
                <span class="state-badge" style="background: ${state.color}20; border: 1px solid ${state.color}; color: ${state.color};">${state.state_key}</span>
              </div>
            </div>
            ${description ? `<div class="state-description">${description}</div>` : ''}
            <textarea id="${textareaId}" class="response-input" data-state="${state.state_key}" placeholder="Leave empty to skip replies for this state">${responseText}</textarea>
            <div class="state-actions">
              <button class="save-state-btn" id="${buttonId}" onclick="saveState('${state.state_key}', '${textareaId}', '${buttonId}')">Save</button>
            </div>
          `;
          container.appendChild(row);
        });

        showStatus('States and responses loaded', 'success');
      } catch (error) {
        showStatus(`Error loading: ${error.message}`, 'error');
        console.error('Load error:', error);
      }
    }

    async function saveState(stateKey, textareaId, buttonId) {
      console.log('SAVE STATE:', stateKey);
      const textarea = document.getElementById(textareaId);
      const button = document.getElementById(buttonId);
      
      if (!textarea || !button) {
        console.error('Could not find textarea or button for state:', stateKey);
        return;
      }

      const originalText = button.textContent;
      button.disabled = true;
      button.textContent = 'Saving...';

      try {
        const responseText = textarea.value.trim();
        
        const payload = {
          state_key: stateKey,
          response_text: responseText,
          description: '',
        };

        const requestUrl = `${BACKEND}/markov/response`;
        console.log('SAVE STATE: Request URL =', requestUrl);
        console.log('SAVE STATE: Payload =', payload);

        const res = await fetch(requestUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });

        console.log('SAVE STATE: Response status =', res.status);

        if (!res.ok) {
          const errorData = await res.json().catch(() => ({}));
          throw new Error(errorData.detail || errorData.message || `HTTP ${res.status}`);
        }

        const data = await res.json();
        console.log('SAVE STATE: Response data =', data);

        // Flash saved state
        button.classList.add('saved');
        button.textContent = 'Saved âœ“';
        setTimeout(() => {
          button.classList.remove('saved');
          button.textContent = originalText;
        }, 2000);

      } catch (error) {
        console.error('SAVE STATE ERROR:', error);
        button.textContent = 'Error';
        setTimeout(() => {
          button.textContent = originalText;
        }, 2000);
      } finally {
        button.disabled = false;
      }
    }


    async function importFromJSON() {
      console.log('IMPORT CLICKED - importFromJSON() called');
      const importBtn = document.getElementById('importBtn');
      const originalText = importBtn.textContent;
      importBtn.disabled = true;
      importBtn.textContent = 'Importing...';

      try {
        const jsonText = document.getElementById('jsonInput').value.trim();
        if (!jsonText) {
          showStatus('Please enter JSON to import', 'error');
          return;
        }

        console.log('IMPORT: Parsing JSON...');
        const data = JSON.parse(jsonText);
        console.log('IMPORT: Parsed data', Object.keys(data));

        // Validate structure
        if (typeof data !== 'object' || data === null) {
          throw new Error('JSON must be an object');
        }

        // Import initial outreach
        if (data.initial_outreach !== undefined && data.initial_outreach !== null) {
          document.getElementById('initialOutreach').value = data.initial_outreach;
          console.log('IMPORT: Set initial_outreach');
          // Save initial outreach
          await saveState('__initial_outreach__', 'initialOutreach', 'saveInitialOutreachBtn');
        }

        // Import state responses - compile to individual saves
        if (data.responses && typeof data.responses === 'object') {
          const stateKeys = Object.keys(data.responses);
          console.log('IMPORT: Compiling', stateKeys.length, 'states to individual saves...');
          
          for (const stateKey of stateKeys) {
            const stateData = data.responses[stateKey];
            const responseText = stateData.response_text || stateData.responseText || '';
            const textareaId = `state-${stateKey}`;
            const buttonId = `save-${stateKey}-btn`;
            
            // Populate textarea
            const textarea = document.getElementById(textareaId);
            if (textarea) {
              textarea.value = responseText;
              // Save state
              await saveState(stateKey, textareaId, buttonId);
            } else {
              console.warn('IMPORT: Textarea not found for state:', stateKey);
            }
          }
        }

        showStatus('JSON imported and saved successfully', 'success');
      } catch (error) {
        console.error('IMPORT ERROR:', error);
        showStatus(`Error importing JSON: ${error.message}`, 'error');
      } finally {
        importBtn.disabled = false;
        importBtn.textContent = originalText;
      }
    }

    // Load on page load
    loadResponses();
  </script>
</body>
</html>
