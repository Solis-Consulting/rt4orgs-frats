<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Markov Response Editor - RT4 CRM</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 0; background: #0f172a; color: #e5e7eb; }
    .shell { max-width: 1200px; margin: 32px auto; padding: 0 16px; }
    .card { background: #020617; border-radius: 16px; padding: 20px 24px; box-shadow: 0 18px 60px rgba(0,0,0,0.6); border: 1px solid #1f2937; margin-bottom: 16px; }
    h1 { margin: 0 0 8px; font-size: 24px; }
    .sub { margin-bottom: 16px; color: #9ca3af; font-size: 14px; }
    .link { color: #38bdf8; text-decoration: none; font-weight: 500; }
    .link:hover { text-decoration: underline; }
    .section { margin-top: 24px; border-top: 1px solid #1f2937; padding-top: 16px; }
    .section-title { font-size: 18px; margin-bottom: 12px; color: #e5e7eb; }
    textarea { width: 100%; min-height: 100px; background: #020617; border: 1px solid #4b5563; border-radius: 8px; padding: 12px; color: #e5e7eb; font-family: 'Monaco', 'Courier New', monospace; font-size: 13px; }
    textarea:focus { outline: none; border-color: #38bdf8; }
    button { background: #0ea5e9; color: #0f172a; border: none; border-radius: 8px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; margin-right: 8px; }
    button:hover { background: #38bdf8; }
    button:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
    .button-secondary { background: #374151; color: #e5e7eb; }
    .button-secondary:hover { background: #4b5563; }
    .success { background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.3); color: #bbf7d0; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .error { background: rgba(248,113,113,0.15); border: 1px solid rgba(248,113,113,0.3); color: #fecaca; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .state-row { margin-bottom: 16px; padding: 12px; background: #111827; border-radius: 8px; border: 1px solid #1f2937; }
    .state-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .state-key { font-family: monospace; font-size: 12px; color: #9ca3af; }
    .state-badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-left: 8px; }
    .state-description { font-size: 11px; color: #6b7280; margin-bottom: 8px; }
    .state-actions { display: flex; gap: 8px; margin-top: 8px; align-items: center; }
    .save-state-btn { background: #0ea5e9; color: #0f172a; border: none; border-radius: 6px; padding: 6px 12px; font-size: 12px; font-weight: 600; cursor: pointer; }
    .save-state-btn:hover { background: #38bdf8; }
    .save-state-btn:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
    .state-status { font-size: 12px; font-weight: 500; margin-left: 8px; min-width: 80px; }
    .state-status.saving { color: #9ca3af; }
    .state-status.success { color: #22c55e; }
    .state-status.error { color: #f87171; }
    .import-status { font-size: 13px; font-weight: 500; margin-top: 8px; padding: 8px; border-radius: 6px; }
    .import-status.success { background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.3); color: #22c55e; }
    .import-status.warning { background: rgba(251,191,36,0.15); border: 1px solid rgba(251,191,36,0.3); color: #fbbf24; }
    .import-status.error { background: rgba(248,113,113,0.15); border: 1px solid rgba(248,113,113,0.3); color: #f87171; }
    .response-input { width: 100%; min-height: 60px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; margin-top: 8px; }
    th, td { padding: 8px 6px; text-align: left; border-bottom: 1px solid #1f2937; }
    th { font-size: 11px; text-transform: uppercase; letter-spacing: 0.06em; color: #6b7280; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="card">
      <a href="index.html" class="link">&larr; Back to list</a>
      <h1>Markov Response Editor</h1>
      <div class="sub">Configure auto-responses for each Markov state and the initial outreach message.</div>

      <div id="status"></div>

      <!-- Initial Outreach Section -->
      <div class="section">
        <div class="section-title">Initial Outreach Message</div>
        <div style="margin-bottom: 8px; font-size: 12px; color: #9ca3af;">
          This message is sent during outbound blasts. Supports placeholders: {"{"}name{"}"}, {"{"}fraternity{"}"}
        </div>
        <textarea id="initialOutreach" placeholder="Hello {name}, we would like to know how {fraternity}'s spring rush could be with a FRESH PNM list..."></textarea>
        <div class="state-actions">
          <button class="save-state-btn" type="button" id="saveInitialOutreachBtn" onclick="saveState('__initial_outreach__', 'initialOutreach')">Save</button>
          <span class="state-status" id="status-__initial_outreach__"></span>
        </div>
      </div>

      <!-- State Responses Section -->
      <div class="section">
        <div class="section-title">State Responses</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Configure the auto-reply message for each Markov state. Leave empty to skip replies for that state.
        </div>
        <div id="stateResponses"></div>
      </div>

      <!-- JSON Import Section -->
      <div class="section">
        <div class="section-title">JSON Import</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Paste JSON to populate all fields. Import automatically saves to backend.
        </div>
        <textarea id="jsonInput" placeholder='{"initial_outreach": "...", "responses": {"state_key": {"response_text": "...", "description": "..."}}}' style="min-height: 150px; font-family: 'Monaco', 'Courier New', monospace; font-size: 12px;"></textarea>
        <div style="margin-top: 12px;">
          <button id="importBtn" type="button" onclick="importFromJSON()">Import JSON</button>
        </div>
        <div id="importStatus" class="import-status" style="display: none;"></div>
      </div>

    </div>
  </div>

  <script type="module">
    import { BACKEND_URL } from '/config.js';
    const BACKEND = BACKEND_URL;
    
    // Log backend URL on load for debugging
    console.log('Markov Response Editor initialized');
    console.log('BACKEND_URL from config:', BACKEND_URL);
    console.log('BACKEND constant:', BACKEND);
    console.log('Location:', window.location.href);

    // States will be loaded from the registry endpoint
    let MARKOV_STATES = [];

    function showStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.className = type;
      statusDiv.textContent = message;
      statusDiv.style.display = 'block';
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 5000);
    }

    async function loadResponses() {
      try {
        console.log('LOAD: BACKEND URL =', BACKEND);
        
        // Step 1: Fetch all states from the registry (authoritative source)
        const statesUrl = `${BACKEND}/markov/states`;
        console.log('LOAD: Fetching states from', statesUrl);
        const statesRes = await fetch(statesUrl);
        console.log('LOAD: States response status =', statesRes.status);
        if (!statesRes.ok) {
          throw new Error(`Failed to load states: ${statesRes.status}`);
        }
        MARKOV_STATES = await statesRes.json();
        console.log('LOAD: Loaded', MARKOV_STATES.length, 'states');

        // Step 2: Fetch configured responses from DB
        const responsesUrl = `${BACKEND}/markov/responses`;
        console.log('LOAD: Fetching responses from', responsesUrl);
        const responsesRes = await fetch(responsesUrl);
        console.log('LOAD: Responses response status =', responsesRes.status);
        if (!responsesRes.ok) {
          throw new Error(`Failed to load responses: ${responsesRes.status}`);
        }
        const responsesData = await responsesRes.json();
        console.log('LOAD: Loaded responses data', Object.keys(responsesData.responses || {}).length, 'configured states');

        // Load initial outreach
        if (responsesData.initial_outreach) {
          document.getElementById('initialOutreach').value = responsesData.initial_outreach;
        }

        // Step 3: Merge states (registry) with responses (config)
        const responses = responsesData.responses || {};
        const container = document.getElementById('stateResponses');
        container.innerHTML = '';

        MARKOV_STATES.forEach(state => {
          // Get config for this state (if it exists)
          const stateConfig = responses[state.state_key] || {};
          const responseText = stateConfig.response_text || '';
          const configDescription = stateConfig.description || '';
          
          // Use description from registry, or fallback to config description
          const description = state.description || configDescription || '';

          const row = document.createElement('div');
          row.className = 'state-row';
          const textareaId = `state-${state.state_key}`;
          const buttonId = `save-${state.state_key}-btn`;
          row.innerHTML = `
            <div class="state-header">
              <div>
                <strong>${state.label || state.state_key}</strong>
                <span class="state-badge" style="background: ${state.color}20; border: 1px solid ${state.color}; color: ${state.color};">${state.state_key}</span>
              </div>
            </div>
            ${description ? `<div class="state-description">${description}</div>` : ''}
            <textarea id="${textareaId}" class="response-input" data-state="${state.state_key}" placeholder="Leave empty to skip replies for this state">${responseText}</textarea>
            <div class="state-actions">
              <button class="save-state-btn" type="button" id="${buttonId}" onclick="saveState('${state.state_key}', '${textareaId}')">Save</button>
              <span class="state-status" id="status-${state.state_key}"></span>
            </div>
          `;
          container.appendChild(row);
        });

        showStatus('States and responses loaded', 'success');
      } catch (error) {
        showStatus(`Error loading: ${error.message}`, 'error');
        console.error('Load error:', error);
      }
    }

    function setStateStatus(stateKey, status, message = '') {
      const statusEl = document.getElementById(`status-${stateKey}`);
      if (!statusEl) return;
      
      // Remove all status classes
      statusEl.classList.remove('saving', 'success', 'error');
      
      if (status === 'saving') {
        statusEl.classList.add('saving');
        statusEl.textContent = 'Saving…';
      } else if (status === 'success') {
        statusEl.classList.add('success');
        statusEl.textContent = '✓ Saved';
        // Clear after 2 seconds
        setTimeout(() => {
          if (statusEl.textContent === '✓ Saved') {
            statusEl.textContent = '';
            statusEl.classList.remove('success');
          }
        }, 2000);
      } else if (status === 'error') {
        statusEl.classList.add('error');
        statusEl.textContent = `✕ ${message || 'Error'}`;
      } else {
        statusEl.textContent = '';
      }
    }

    async function saveState(stateKey, textareaId) {
      console.log('SAVE STATE:', stateKey);
      const textarea = document.getElementById(textareaId);
      const buttonId = textareaId === 'initialOutreach' ? 'saveInitialOutreachBtn' : `save-${stateKey}-btn`;
      const button = document.getElementById(buttonId);
      
      if (!textarea) {
        console.error('Could not find textarea for state:', stateKey);
        return false;
      }

      if (button) {
        button.disabled = true;
      }
      setStateStatus(stateKey, 'saving');

      try {
        const responseText = textarea.value.trim();
        
        const payload = {
          state_key: stateKey,
          response_text: responseText,
          description: '',
        };

        const requestUrl = `${BACKEND}/markov/response`;
        console.log('SAVE STATE: Request URL =', requestUrl);
        console.log('SAVE STATE: Payload =', payload);

        const res = await fetch(requestUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });

        console.log('SAVE STATE: Response status =', res.status);

        if (!res.ok) {
          const errorData = await res.json().catch(() => ({}));
          throw new Error(errorData.detail || errorData.message || `HTTP ${res.status}`);
        }

        const data = await res.json();
        console.log('SAVE STATE: Response data =', data);

        setStateStatus(stateKey, 'success');
        return true;

      } catch (error) {
        console.error('SAVE STATE ERROR:', error);
        setStateStatus(stateKey, 'error', error.message);
        return false;
      } finally {
        if (button) {
          button.disabled = false;
        }
      }
    }


    function showImportSummary(ok, skipped, failed) {
      const statusEl = document.getElementById('importStatus');
      if (!statusEl) return;
      
      statusEl.style.display = 'block';
      statusEl.classList.remove('success', 'warning', 'error');
      
      const parts = [];
      if (ok > 0) {
        parts.push(`✔ Imported ${ok} ${ok === 1 ? 'state' : 'states'}`);
      }
      if (skipped > 0) {
        parts.push(`⚠ ${skipped} ${skipped === 1 ? 'state' : 'states'} skipped (unknown)`);
      }
      if (failed > 0) {
        parts.push(`✕ ${failed} ${failed === 1 ? 'state' : 'states'} failed`);
      }
      
      if (failed > 0) {
        statusEl.classList.add('error');
      } else if (skipped > 0) {
        statusEl.classList.add('warning');
      } else {
        statusEl.classList.add('success');
      }
      
      statusEl.textContent = parts.join(' | ');
    }

    async function importFromJSON(event) {
      // Prevent any form submission
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }

      console.log('IMPORT CLICKED - importFromJSON() called');
      
      // Immediate visual feedback
      const statusEl = document.getElementById('importStatus');
      if (statusEl) {
        statusEl.style.display = 'block';
        statusEl.classList.remove('success', 'warning', 'error');
        statusEl.classList.add('warning');
        statusEl.textContent = 'Parsing JSON…';
      }

      const importBtn = document.getElementById('importBtn');
      const originalText = importBtn ? importBtn.textContent : 'Import JSON';
      if (importBtn) {
        importBtn.disabled = true;
        importBtn.textContent = 'Importing...';
      }

      let ok = 0;
      let skipped = 0;
      let failed = 0;

      try {
        const jsonText = document.getElementById('jsonInput').value.trim();
        if (!jsonText) {
          if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.classList.remove('warning');
            statusEl.classList.add('error');
            statusEl.textContent = '✕ Please enter JSON to import';
          }
          return;
        }

        console.log('IMPORT: Parsing JSON...');
        if (statusEl) {
          statusEl.textContent = 'Parsing JSON…';
        }
        const data = JSON.parse(jsonText);
        console.log('IMPORT: Parsed data', Object.keys(data));
        
        if (statusEl) {
          statusEl.textContent = 'Applying to UI…';
        }

        // Validate structure
        if (typeof data !== 'object' || data === null) {
          throw new Error('JSON must be an object');
        }

        // STEP 1: Update UI fields FIRST (instant visual feedback)
        // Initial outreach
        if (data.initial_outreach !== undefined && data.initial_outreach !== null) {
          const initialTextarea = document.getElementById('initialOutreach');
          if (initialTextarea) {
            initialTextarea.value = data.initial_outreach;
            console.log('IMPORT: Set initial_outreach in UI');
          }
        }

        // State responses - update UI fields synchronously
        if (data.responses && typeof data.responses === 'object') {
          for (const [stateKey, stateData] of Object.entries(data.responses)) {
            const responseText = stateData.response_text || stateData.responseText || '';
            const textareaId = `state-${stateKey}`;
            const textarea = document.getElementById(textareaId);
            
            if (textarea) {
              // Update UI immediately (instant visual feedback)
              textarea.value = responseText;
              console.log('IMPORT: Set', stateKey, 'in UI');
            } else {
              // State not found - skip with warning
              console.warn('IMPORT: State not found in UI:', stateKey);
              skipped++;
            }
          }
        }

        // Show UI update confirmation
        if (statusEl) {
          statusEl.textContent = 'UI updated, saving to backend…';
        }

        // STEP 2: Now persist to backend (with per-state feedback)
        // Save initial outreach
        if (data.initial_outreach !== undefined && data.initial_outreach !== null) {
          try {
            const success = await saveState('__initial_outreach__', 'initialOutreach');
            success ? ok++ : failed++;
          } catch (e) {
            console.error('IMPORT: Failed to save initial_outreach:', e);
            failed++;
          }
        }

        // Save state responses - compile to individual saves
        if (data.responses && typeof data.responses === 'object') {
          for (const [stateKey, stateData] of Object.entries(data.responses)) {
            const textareaId = `state-${stateKey}`;
            const textarea = document.getElementById(textareaId);
            
            if (!textarea) {
              // Already counted as skipped above
              continue;
            }

            try {
              const success = await saveState(stateKey, textareaId);
              success ? ok++ : failed++;
            } catch (e) {
              console.error('IMPORT: Failed to save state', stateKey, ':', e);
              failed++;
            }
          }
        }

        // Show aggregate summary
        showImportSummary(ok, skipped, failed);

      } catch (error) {
        console.error('IMPORT ERROR:', error);
        if (statusEl) {
          statusEl.style.display = 'block';
          statusEl.classList.remove('success', 'warning');
          statusEl.classList.add('error');
          statusEl.textContent = `✕ Import error: ${error.message}`;
        }
        showStatus(`Error importing JSON: ${error.message}`, 'error');
      } finally {
        if (importBtn) {
          importBtn.disabled = false;
          importBtn.textContent = originalText;
        }
      }
    }

    // Load on page load
    loadResponses();
  </script>
</body>
</html>
