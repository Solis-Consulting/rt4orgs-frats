<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Markov Response Editor - RT4 CRM</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 0; background: #0f172a; color: #e5e7eb; }
    .shell { max-width: 1200px; margin: 32px auto; padding: 0 16px; }
    .card { background: #020617; border-radius: 16px; padding: 20px 24px; box-shadow: 0 18px 60px rgba(0,0,0,0.6); border: 1px solid #1f2937; margin-bottom: 16px; }
    h1 { margin: 0 0 8px; font-size: 24px; }
    .sub { margin-bottom: 16px; color: #9ca3af; font-size: 14px; }
    .link { color: #38bdf8; text-decoration: none; font-weight: 500; }
    .link:hover { text-decoration: underline; }
    .section { margin-top: 24px; border-top: 1px solid #1f2937; padding-top: 16px; }
    .section-title { font-size: 18px; margin-bottom: 12px; color: #e5e7eb; }
    textarea { width: 100%; min-height: 100px; background: #020617; border: 1px solid #4b5563; border-radius: 8px; padding: 12px; color: #e5e7eb; font-family: 'Monaco', 'Courier New', monospace; font-size: 13px; }
    textarea:focus { outline: none; border-color: #38bdf8; }
    button { background: #0ea5e9; color: #0f172a; border: none; border-radius: 8px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; margin-right: 8px; }
    button:hover { background: #38bdf8; }
    button:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
    .button-secondary { background: #374151; color: #e5e7eb; }
    .button-secondary:hover { background: #4b5563; }
    .success { background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.3); color: #bbf7d0; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .error { background: rgba(248,113,113,0.15); border: 1px solid rgba(248,113,113,0.3); color: #fecaca; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .state-row { margin-bottom: 16px; padding: 12px; background: #111827; border-radius: 8px; border: 1px solid #1f2937; }
    .state-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .state-key { font-family: monospace; font-size: 12px; color: #9ca3af; }
    .state-badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-left: 8px; }
    .state-description { font-size: 11px; color: #6b7280; margin-bottom: 8px; }
    .response-input { width: 100%; min-height: 60px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; margin-top: 8px; }
    th, td { padding: 8px 6px; text-align: left; border-bottom: 1px solid #1f2937; }
    th { font-size: 11px; text-transform: uppercase; letter-spacing: 0.06em; color: #6b7280; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="card">
      <a href="index.html" class="link">&larr; Back to list</a>
      <h1>Markov Response Editor</h1>
      <div class="sub">Configure auto-responses for each Markov state and the initial outreach message.</div>

      <div id="status"></div>

      <!-- Initial Outreach Section -->
      <div class="section">
        <div class="section-title">Initial Outreach Message</div>
        <div style="margin-bottom: 8px; font-size: 12px; color: #9ca3af;">
          This message is sent during outbound blasts. Supports placeholders: {"{"}name{"}"}, {"{"}fraternity{"}"}
        </div>
        <textarea id="initialOutreach" placeholder="Hello {name}, we would like to know how {fraternity}'s spring rush could be with a FRESH PNM list..."></textarea>
      </div>

      <!-- State Responses Section -->
      <div class="section">
        <div class="section-title">State Responses</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Configure the auto-reply message for each Markov state. Leave empty to skip replies for that state.
        </div>
        <div id="stateResponses"></div>
      </div>

      <!-- JSON Import Section -->
      <div class="section">
        <div class="section-title">JSON Import</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Paste JSON to populate all fields. Import automatically saves to backend.
        </div>
        <textarea id="jsonInput" placeholder='{"initial_outreach": "...", "responses": {"state_key": {"response_text": "...", "description": "..."}}}' style="min-height: 150px; font-family: 'Monaco', 'Courier New', monospace; font-size: 12px;"></textarea>
        <div style="margin-top: 12px;">
          <button id="importBtn" onclick="importFromJSON()">Import JSON</button>
        </div>
      </div>

      <div style="margin-top: 24px;">
        <button id="saveBtn" onclick="saveResponses()">Save All Changes</button>
        <button class="button-secondary" onclick="loadResponses()" style="opacity: 0.7;">Reload</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { BACKEND_URL } from '/config.js';
    const BACKEND = BACKEND_URL;
    
    // Log backend URL on load for debugging
    console.log('Markov Response Editor initialized');
    console.log('BACKEND_URL from config:', BACKEND_URL);
    console.log('BACKEND constant:', BACKEND);
    console.log('Location:', window.location.href);

    // States will be loaded from the registry endpoint
    let MARKOV_STATES = [];

    function showStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.className = type;
      statusDiv.textContent = message;
      statusDiv.style.display = 'block';
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 5000);
    }

    async function loadResponses() {
      try {
        console.log('LOAD: BACKEND URL =', BACKEND);
        
        // Step 1: Fetch all states from the registry (authoritative source)
        const statesUrl = `${BACKEND}/markov/states`;
        console.log('LOAD: Fetching states from', statesUrl);
        const statesRes = await fetch(statesUrl);
        console.log('LOAD: States response status =', statesRes.status);
        if (!statesRes.ok) {
          throw new Error(`Failed to load states: ${statesRes.status}`);
        }
        MARKOV_STATES = await statesRes.json();
        console.log('LOAD: Loaded', MARKOV_STATES.length, 'states');

        // Step 2: Fetch configured responses from DB
        const responsesUrl = `${BACKEND}/markov/responses`;
        console.log('LOAD: Fetching responses from', responsesUrl);
        const responsesRes = await fetch(responsesUrl);
        console.log('LOAD: Responses response status =', responsesRes.status);
        if (!responsesRes.ok) {
          throw new Error(`Failed to load responses: ${responsesRes.status}`);
        }
        const responsesData = await responsesRes.json();
        console.log('LOAD: Loaded responses data', Object.keys(responsesData.responses || {}).length, 'configured states');

        // Load initial outreach
        if (responsesData.initial_outreach) {
          document.getElementById('initialOutreach').value = responsesData.initial_outreach;
        }

        // Step 3: Merge states (registry) with responses (config)
        const responses = responsesData.responses || {};
        const container = document.getElementById('stateResponses');
        container.innerHTML = '';

        MARKOV_STATES.forEach(state => {
          // Get config for this state (if it exists)
          const stateConfig = responses[state.state_key] || {};
          const responseText = stateConfig.response_text || '';
          const configDescription = stateConfig.description || '';
          
          // Use description from registry, or fallback to config description
          const description = state.description || configDescription || '';

          const row = document.createElement('div');
          row.className = 'state-row';
          row.innerHTML = `
            <div class="state-header">
              <div>
                <strong>${state.label || state.state_key}</strong>
                <span class="state-badge" style="background: ${state.color}20; border: 1px solid ${state.color}; color: ${state.color};">${state.state_key}</span>
              </div>
            </div>
            ${description ? `<div class="state-description">${description}</div>` : ''}
            <textarea class="response-input" data-state="${state.state_key}" placeholder="Leave empty to skip replies for this state">${responseText}</textarea>
          `;
          container.appendChild(row);
        });

        showStatus('States and responses loaded', 'success');
      } catch (error) {
        showStatus(`Error loading: ${error.message}`, 'error');
        console.error('Load error:', error);
      }
    }

    async function saveResponses(isAutoSave = false) {
      if (!isAutoSave) {
        console.log('SAVE CLICKED - saveResponses() called');
      }
      const saveBtn = document.getElementById('saveBtn');
      const wasDisabled = saveBtn ? saveBtn.disabled : false;
      if (!isAutoSave && saveBtn) {
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
      }

      try {
        console.log('SAVE: BACKEND URL =', BACKEND);
        
        // Collect initial outreach
        const initialOutreach = document.getElementById('initialOutreach').value.trim();

        // Collect state responses
        const responses = {};
        document.querySelectorAll('.response-input').forEach(textarea => {
          const stateKey = textarea.getAttribute('data-state');
          const responseText = textarea.value.trim();
          if (stateKey) {
            responses[stateKey] = {
              response_text: responseText,
              description: '', // Can be enhanced later
            };
          }
        });

        const payload = {
          initial_outreach: initialOutreach,
          responses: responses,
        };

        const requestUrl = `${BACKEND}/markov/responses`;
        console.log('SAVE: Request URL =', requestUrl);
        console.log('SAVE: Payload =', JSON.stringify(payload, null, 2));

        const res = await fetch(requestUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });

        console.log('SAVE: Response status =', res.status);
        console.log('SAVE: Response ok =', res.ok);

        const data = await res.json();
        console.log('SAVE: Response data =', data);

        if (!res.ok || !data.ok) {
          throw new Error(data.error || data.message || `HTTP ${res.status}`);
        }

        if (!isAutoSave) {
          showStatus('All responses saved successfully', 'success');
        }
      } catch (error) {
        console.error('SAVE ERROR:', error);
        if (!isAutoSave) {
          showStatus(`Error saving: ${error.message}`, 'error');
        } else {
          throw error; // Re-throw for importFromJSON to handle
        }
      } finally {
        if (!isAutoSave && saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save All Changes';
        } else if (saveBtn) {
          saveBtn.disabled = wasDisabled;
        }
      }
    }


    async function importFromJSON() {
      console.log('IMPORT CLICKED - importFromJSON() called');
      const importBtn = document.getElementById('importBtn');
      const originalText = importBtn.textContent;
      importBtn.disabled = true;
      importBtn.textContent = 'Importing...';

      try {
        const jsonText = document.getElementById('jsonInput').value.trim();
        if (!jsonText) {
          showStatus('Please enter JSON to import', 'error');
          return;
        }

        console.log('IMPORT: Parsing JSON...');
        const data = JSON.parse(jsonText);
        console.log('IMPORT: Parsed data', Object.keys(data));

        // Validate structure
        if (typeof data !== 'object' || data === null) {
          throw new Error('JSON must be an object');
        }

        // Import initial outreach
        if (data.initial_outreach !== undefined && data.initial_outreach !== null) {
          document.getElementById('initialOutreach').value = data.initial_outreach;
          console.log('IMPORT: Set initial_outreach');
        }

        // Import state responses
        if (data.responses && typeof data.responses === 'object') {
          document.querySelectorAll('.response-input').forEach(textarea => {
            const stateKey = textarea.getAttribute('data-state');
            if (stateKey && data.responses[stateKey]) {
              const stateData = data.responses[stateKey];
              const responseText = stateData.response_text || stateData.responseText || '';
              textarea.value = responseText;
            }
          });
          console.log('IMPORT: Imported', Object.keys(data.responses).length, 'state responses');
        }

        // Auto-save immediately after import
        console.log('IMPORT: Auto-saving to backend...');
        await saveResponses(true); // Pass true to indicate this is from import

        // Re-hydrate UI from backend to ensure UI matches DB
        console.log('IMPORT: Re-hydrating UI from backend...');
        await loadResponses();

        showStatus('JSON imported and saved successfully', 'success');
      } catch (error) {
        console.error('IMPORT ERROR:', error);
        showStatus(`Error importing JSON: ${error.message}`, 'error');
      } finally {
        importBtn.disabled = false;
        importBtn.textContent = originalText;
      }
    }

    // Load on page load
    loadResponses();
  </script>
</body>
</html>
