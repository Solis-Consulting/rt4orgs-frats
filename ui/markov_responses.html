<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Markov Response Editor - RT4 CRM</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 0; background: #0f172a; color: #e5e7eb; }
    .shell { max-width: 1200px; margin: 32px auto; padding: 0 16px; }
    .card { background: #020617; border-radius: 16px; padding: 20px 24px; box-shadow: 0 18px 60px rgba(0,0,0,0.6); border: 1px solid #1f2937; margin-bottom: 16px; }
    h1 { margin: 0 0 8px; font-size: 24px; }
    .sub { margin-bottom: 16px; color: #9ca3af; font-size: 14px; }
    .link { color: #38bdf8; text-decoration: none; font-weight: 500; }
    .link:hover { text-decoration: underline; }
    .section { margin-top: 24px; border-top: 1px solid #1f2937; padding-top: 16px; }
    .section-title { font-size: 18px; margin-bottom: 12px; color: #e5e7eb; }
    textarea { width: 100%; min-height: 100px; background: #020617; border: 1px solid #4b5563; border-radius: 8px; padding: 12px; color: #e5e7eb; font-family: 'Monaco', 'Courier New', monospace; font-size: 13px; }
    textarea:focus { outline: none; border-color: #38bdf8; }
    button { background: #0ea5e9; color: #0f172a; border: none; border-radius: 8px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; margin-right: 8px; }
    button:hover { background: #38bdf8; }
    button:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
    .button-secondary { background: #374151; color: #e5e7eb; }
    .button-secondary:hover { background: #4b5563; }
    .success { background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.3); color: #bbf7d0; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .error { background: rgba(248,113,113,0.15); border: 1px solid rgba(248,113,113,0.3); color: #fecaca; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .state-row { margin-bottom: 16px; padding: 12px; background: #111827; border-radius: 8px; border: 1px solid #1f2937; }
    .state-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .state-key { font-family: monospace; font-size: 12px; color: #9ca3af; }
    .state-badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-left: 8px; }
    .state-description { font-size: 11px; color: #6b7280; margin-bottom: 8px; }
    .state-actions { display: flex; gap: 8px; margin-top: 8px; align-items: center; }
    .save-state-btn { background: #0ea5e9; color: #0f172a; border: none; border-radius: 6px; padding: 6px 12px; font-size: 12px; font-weight: 600; cursor: pointer; }
    .save-state-btn:hover { background: #38bdf8; }
    .save-state-btn:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
    .state-status { 
      font-size: 12px; 
      font-weight: 600; 
      margin-left: 8px; 
      min-width: 80px;
      display: inline-block;
    }
    .state-status.saving { 
      color: #3b82f6; /* blue */
    }
    .state-status.success { 
      color: #22c55e; /* green */
    }
    .state-status.error { 
      color: #ef4444; /* red */
    }
    .import-status { font-size: 13px; font-weight: 500; margin-top: 8px; padding: 8px; border-radius: 6px; }
    .import-status.success { background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.3); color: #22c55e; }
    .import-status.warning { background: rgba(251,191,36,0.15); border: 1px solid rgba(251,191,36,0.3); color: #fbbf24; }
    .import-status.error { background: rgba(248,113,113,0.15); border: 1px solid rgba(248,113,113,0.3); color: #f87171; }
    .response-input { width: 100%; min-height: 60px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; margin-top: 8px; }
    th, td { padding: 8px 6px; text-align: left; border-bottom: 1px solid #1f2937; }
    th { font-size: 11px; text-transform: uppercase; letter-spacing: 0.06em; color: #6b7280; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="card">
      <a href="index.html" class="link">&larr; Back to list</a>
      <h1>Markov Response Editor</h1>
      <div class="sub">Configure auto-responses for each Markov state and the initial outreach message.</div>

      <div id="status"></div>

      <!-- Initial Outreach Section -->
      <div class="section">
        <div class="section-title">Initial Outreach Message</div>
        <div style="margin-bottom: 8px; font-size: 12px; color: #9ca3af;">
          This message is sent during outbound blasts. Supports placeholders: {"{"}name{"}"}, {"{"}fraternity{"}"}
        </div>
        <textarea id="initialOutreach" placeholder="Hello {name}, we would like to know how {fraternity}'s spring rush could be with a FRESH PNM list..."></textarea>
        <div class="state-actions">
          <button class="save-state-btn" type="button" id="saveInitialOutreachBtn" onclick="saveStateFromTextarea('__initial_outreach__', 'initialOutreach')">Save</button>
          <span class="state-status" id="status-__initial_outreach__"></span>
        </div>
      </div>

      <!-- State Responses Section -->
      <div class="section">
        <div class="section-title">State Responses</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Configure the auto-reply message for each Markov state. Leave empty to skip replies for that state.
        </div>
        <div id="stateResponses"></div>
      </div>

      <!-- JSON Import Section -->
      <div class="section">
        <div class="section-title">JSON Import</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Paste JSON to populate all fields. Import automatically saves to backend.
        </div>
        <textarea id="jsonInput" placeholder='{"initial_outreach": "...", "responses": {"state_key": {"response_text": "...", "description": "..."}}}' style="min-height: 150px; font-family: 'Monaco', 'Courier New', monospace; font-size: 12px;"></textarea>
        <div style="margin-top: 12px;">
          <button id="importBtn" type="button" onclick="importFromJSON()">Import JSON</button>
        </div>
        <div id="importStatus" class="import-status" style="display: none;"></div>
      </div>

    </div>
  </div>

  <script type="module">
    import { BACKEND_URL } from '/config.js';
    const BACKEND = BACKEND_URL;
    
    // Log backend URL on load for debugging
    console.log('Markov Response Editor initialized');
    console.log('BACKEND_URL from config:', BACKEND_URL);
    console.log('BACKEND constant:', BACKEND);
    console.log('Location:', window.location.href);

    // States will be loaded from the registry endpoint
    let MARKOV_STATES = [];

    function showStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.className = type;
      statusDiv.textContent = message;
      statusDiv.style.display = 'block';
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 5000);
    }

    async function loadResponses() {
      try {
        console.log('LOAD: BACKEND URL =', BACKEND);
        
        // Step 1: Fetch all states from the registry (authoritative source)
        const statesUrl = `${BACKEND}/markov/states`;
        console.log('LOAD: Fetching states from', statesUrl);
        const statesRes = await fetch(statesUrl);
        console.log('LOAD: States response status =', statesRes.status);
        if (!statesRes.ok) {
          throw new Error(`Failed to load states: ${statesRes.status}`);
        }
        MARKOV_STATES = await statesRes.json();
        console.log('LOAD: Loaded', MARKOV_STATES.length, 'states');

        // Step 2: Fetch configured responses from DB
        const responsesUrl = `${BACKEND}/markov/responses`;
        console.log('LOAD: Fetching responses from', responsesUrl);
        const responsesRes = await fetch(responsesUrl);
        console.log('LOAD: Responses response status =', responsesRes.status);
        if (!responsesRes.ok) {
          throw new Error(`Failed to load responses: ${responsesRes.status}`);
        }
        const responsesData = await responsesRes.json();
        console.log('LOAD: Loaded responses data', Object.keys(responsesData.responses || {}).length, 'configured states');

        // Load initial outreach
        if (responsesData.initial_outreach) {
          document.getElementById('initialOutreach').value = responsesData.initial_outreach;
        }

        // Step 3: Merge states (registry) with responses (config)
        const responses = responsesData.responses || {};
        const container = document.getElementById('stateResponses');
        container.innerHTML = '';

        MARKOV_STATES.forEach(state => {
          // Get config for this state (if it exists)
          const stateConfig = responses[state.state_key] || {};
          const responseText = stateConfig.response_text || '';
          const configDescription = stateConfig.description || '';
          
          // Use description from registry, or fallback to config description
          const description = state.description || configDescription || '';

          const row = document.createElement('div');
          row.className = 'state-row';
          const textareaId = `state-${state.state_key}`;
          const buttonId = `save-${state.state_key}-btn`;
          row.innerHTML = `
            <div class="state-header">
              <div>
                <strong>${state.label || state.state_key}</strong>
                <span class="state-badge" style="background: ${state.color}20; border: 1px solid ${state.color}; color: ${state.color};">${state.state_key}</span>
              </div>
            </div>
            ${description ? `<div class="state-description">${description}</div>` : ''}
            <textarea id="${textareaId}" class="response-input" data-state="${state.state_key}" placeholder="Leave empty to skip replies for this state">${responseText}</textarea>
            <div class="state-actions">
              <button class="save-state-btn" type="button" id="${buttonId}" onclick="saveStateFromTextarea('${state.state_key}', '${textareaId}')">Save</button>
              <span class="state-status" id="status-${state.state_key}"></span>
            </div>
          `;
          container.appendChild(row);
        });

        showStatus('States and responses loaded', 'success');
      } catch (error) {
        showStatus(`Error loading: ${error.message}`, 'error');
        console.error('Load error:', error);
      }
    }

    function setStateStatus(stateKey, status, message = '') {
      const statusEl = document.getElementById(`status-${stateKey}`);
      if (!statusEl) return;
      
      // Remove all status classes
      statusEl.classList.remove('saving', 'success', 'error');
      
      if (status === 'saving') {
        statusEl.classList.add('saving');
        statusEl.textContent = 'Saving‚Ä¶';
      } else if (status === 'success') {
        statusEl.classList.add('success');
        statusEl.textContent = '‚úì Saved';
        // Clear after 2 seconds
        setTimeout(() => {
          if (statusEl.textContent === '‚úì Saved') {
            statusEl.textContent = '';
            statusEl.classList.remove('success');
          }
        }, 2000);
      } else if (status === 'error') {
        statusEl.classList.add('error');
        statusEl.textContent = `‚úï ${message || 'Error'}`;
      } else {
        statusEl.textContent = '';
      }
    }

    async function saveState(stateKey, cfg) {
      log('‚ñ∂Ô∏è SAVE CLICKED', stateKey);
      setStateStatus(stateKey, 'saving', 'Saving‚Ä¶');

      try {
        const payload = {
          state_key: stateKey,
          response_text: cfg.response_text || cfg || '',
          description: cfg.description || '',
        };

        log('üì§ sending payload', payload);

        const res = await fetch(`${BACKEND}/markov/response`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });

        log('üì• response status', res.status, stateKey);

        // MUST consume response body - browsers require this
        const data = await res.json();
        log('üì• response json', data);

        if (!res.ok) {
          log('SAVE FAILED', stateKey, `HTTP ${res.status}: ${JSON.stringify(data)}`);
          throw new Error(data.detail || data.message || `HTTP ${res.status}`);
        }

        log('‚úÖ SAVE CONFIRMED', stateKey);
        setStateStatus(stateKey, 'success', 'Saved');
        return true;
      } catch (err) {
        log('SAVE FAILED', stateKey, err);
        setStateStatus(stateKey, 'error', err.message);
        return false;
      }
    }

    async function saveStateFromTextarea(stateKey, textareaId) {
      const textarea = document.getElementById(textareaId);
      const buttonId = textareaId === 'initialOutreach' ? 'saveInitialOutreachBtn' : `save-${stateKey}-btn`;
      const button = document.getElementById(buttonId);
      
      if (!textarea) {
        log('Textarea not found', textareaId);
        return false;
      }

      if (button) {
        button.disabled = true;
      }

      try {
        const responseText = textarea.value.trim();
        const success = await saveState(stateKey, { response_text: responseText });
        return success;
      } finally {
        if (button) {
          button.disabled = false;
        }
      }
    }


    function log(...args) {
      console.log('[MARKOV_UI]', ...args);
    }
    
    // Keep logUI for backward compatibility
    function logUI(event, data = '') {
      log(event, data);
    }

    function hydrateUIFromJSON(payload) {
      logUI('hydrate:start', Object.keys(payload));
      
      // Update initial outreach
      if (payload.initial_outreach) {
        const initialTextarea = document.getElementById('initialOutreach');
        if (initialTextarea) {
          initialTextarea.value = payload.initial_outreach;
          setStateStatus('__initial_outreach__', 'success', 'Updated');
          logUI('hydrate:initial_outreach', 'updated');
        }
      }

      // Update state responses
      if (payload.responses && typeof payload.responses === 'object') {
        Object.entries(payload.responses).forEach(([stateKey, stateData]) => {
          const responseText = stateData.response_text || stateData.responseText || '';
          const textareaId = `state-${stateKey}`;
          const textarea = document.getElementById(textareaId);
          
          if (!textarea) {
            setStateStatus(stateKey, 'error', 'State not found');
            logUI('hydrate:state:notfound', stateKey);
            return;
          }

          textarea.value = responseText;
          setStateStatus(stateKey, 'success', 'Updated');
          logUI('hydrate:state:updated', stateKey);
        });
      }
      
      logUI('hydrate:complete');
    }

    function showImportSummary(ok, skipped, failed) {
      const statusEl = document.getElementById('importStatus');
      if (!statusEl) return;
      
      statusEl.style.display = 'block';
      statusEl.classList.remove('success', 'warning', 'error');
      
      const parts = [];
      if (ok > 0) {
        parts.push(`‚úî Imported ${ok} ${ok === 1 ? 'state' : 'states'}`);
      }
      if (skipped > 0) {
        parts.push(`‚ö† ${skipped} ${skipped === 1 ? 'state' : 'states'} skipped (unknown)`);
      }
      if (failed > 0) {
        parts.push(`‚úï ${failed} ${failed === 1 ? 'state' : 'states'} failed`);
      }
      
      if (failed > 0) {
        statusEl.classList.add('error');
      } else if (skipped > 0) {
        statusEl.classList.add('warning');
      } else {
        statusEl.classList.add('success');
      }
      
      statusEl.textContent = parts.join(' | ');
    }

    async function importFromJSON(event) {
      // Prevent any form submission
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }

      log('Import clicked');
      
      const importBtn = document.getElementById('importBtn');
      const originalText = importBtn ? importBtn.textContent : 'Import JSON';
      if (importBtn) {
        importBtn.disabled = true;
        importBtn.textContent = 'Importing...';
      }

      const statusEl = document.getElementById('importStatus');
      if (statusEl) {
        statusEl.style.display = 'block';
        statusEl.classList.remove('success', 'warning', 'error');
        statusEl.classList.add('warning');
        statusEl.textContent = 'Parsing JSON‚Ä¶';
      }

      let ok = 0;
      let skipped = 0;
      let failed = 0;

      try {
        const jsonText = document.getElementById('jsonInput').value.trim();
        if (!jsonText) {
          log('JSON parse error', 'Empty JSON');
          if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.classList.remove('warning');
            statusEl.classList.add('error');
            statusEl.textContent = '‚úï Please enter JSON to import';
          }
          return;
        }

        let parsed;
        try {
          parsed = JSON.parse(jsonText);
          log('Parsed JSON', parsed);
        } catch (e) {
          log('JSON parse error', e);
          if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.classList.remove('warning');
            statusEl.classList.add('error');
            statusEl.textContent = '‚úï Invalid JSON';
          }
          return;
        }

        // 1Ô∏è‚É£ Initial outreach
        if (parsed.initial_outreach) {
          log('Saving initial_outreach');
          const initialTextarea = document.getElementById('initialOutreach');
          if (initialTextarea) {
            initialTextarea.value = parsed.initial_outreach;
            const success = await saveState('__initial_outreach__', { response_text: parsed.initial_outreach });
            if (success) {
              ok++;
            } else {
              failed++;
            }
          }
        }

        // 2Ô∏è‚É£ Per-state propagation
        if (parsed.responses && typeof parsed.responses === 'object') {
          for (const [stateKey, cfg] of Object.entries(parsed.responses)) {
            log('Saving state', stateKey, cfg);

            const textarea = document.querySelector(`textarea[data-state="${stateKey}"]`) || 
                           document.getElementById(`state-${stateKey}`);

            if (!textarea) {
              log('STATE NOT FOUND IN UI', stateKey);
              setStateStatus(stateKey, 'error', 'State not found in UI');
              skipped++;
              continue;
            }

            textarea.value = cfg.response_text || cfg.responseText || '';
            const success = await saveState(stateKey, cfg);
            if (success) {
              ok++;
            } else {
              failed++;
            }
          }
        }

        log('Import complete', { ok, skipped, failed });
        showImportSummary(ok, skipped, failed);

      } catch (error) {
        log('Import error', error);
        console.error('IMPORT ERROR:', error);
        if (statusEl) {
          statusEl.style.display = 'block';
          statusEl.classList.remove('success', 'warning');
          statusEl.classList.add('error');
          statusEl.textContent = `‚úï Import error: ${error.message}`;
        }
      } finally {
        if (importBtn) {
          importBtn.disabled = false;
          importBtn.textContent = originalText;
        }
      }
    }

    // Expose functions to global scope for onclick handlers
    window.saveStateFromTextarea = saveStateFromTextarea;
    window.importFromJSON = importFromJSON;
    window.saveState = saveState;

    // Load on page load
    loadResponses();
  </script>
</body>
</html>
