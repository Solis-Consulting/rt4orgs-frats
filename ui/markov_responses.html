<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Markov Response Editor - RT4 CRM</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 0; background: #0f172a; color: #e5e7eb; }
    .shell { max-width: 1200px; margin: 32px auto; padding: 0 16px; }
    .card { background: #020617; border-radius: 16px; padding: 20px 24px; box-shadow: 0 18px 60px rgba(0,0,0,0.6); border: 1px solid #1f2937; margin-bottom: 16px; }
    h1 { margin: 0 0 8px; font-size: 24px; }
    .sub { margin-bottom: 16px; color: #9ca3af; font-size: 14px; }
    .link { color: #38bdf8; text-decoration: none; font-weight: 500; }
    .link:hover { text-decoration: underline; }
    .section { margin-top: 24px; border-top: 1px solid #1f2937; padding-top: 16px; }
    .section-title { font-size: 18px; margin-bottom: 12px; color: #e5e7eb; }
    textarea { width: 100%; min-height: 100px; background: #020617; border: 1px solid #4b5563; border-radius: 8px; padding: 12px; color: #e5e7eb; font-family: 'Monaco', 'Courier New', monospace; font-size: 13px; }
    textarea:focus { outline: none; border-color: #38bdf8; }
    button { background: #0ea5e9; color: #0f172a; border: none; border-radius: 8px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; margin-right: 8px; }
    button:hover { background: #38bdf8; }
    button:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
    .button-secondary { background: #374151; color: #e5e7eb; }
    .button-secondary:hover { background: #4b5563; }
    .success { background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.3); color: #bbf7d0; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .error { background: rgba(248,113,113,0.15); border: 1px solid rgba(248,113,113,0.3); color: #fecaca; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .state-row { margin-bottom: 16px; padding: 12px; background: #111827; border-radius: 8px; border: 1px solid #1f2937; }
    .state-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .state-key { font-family: monospace; font-size: 12px; color: #9ca3af; }
    .state-badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-left: 8px; }
    .state-description { font-size: 11px; color: #6b7280; margin-bottom: 8px; }
    .state-actions { display: flex; gap: 8px; margin-top: 8px; align-items: center; }
    .save-state-btn { background: #0ea5e9; color: #0f172a; border: none; border-radius: 6px; padding: 6px 12px; font-size: 12px; font-weight: 600; cursor: pointer; }
    .save-state-btn:hover { background: #38bdf8; }
    .save-state-btn:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
    .state-status { 
      font-size: 12px; 
      font-weight: 600; 
      margin-left: 8px; 
      min-width: 80px;
      display: inline-block;
    }
    .state-status.saving { 
      color: #3b82f6; /* blue */
    }
    .state-status.success { 
      color: #22c55e; /* green */
    }
    .state-status.error { 
      color: #ef4444; /* red */
    }
    .import-status { font-size: 13px; font-weight: 500; margin-top: 8px; padding: 8px; border-radius: 6px; }
    .import-status.success { background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.3); color: #22c55e; }
    .import-status.warning { background: rgba(251,191,36,0.15); border: 1px solid rgba(251,191,36,0.3); color: #fbbf24; }
    .import-status.error { background: rgba(248,113,113,0.15); border: 1px solid rgba(248,113,113,0.3); color: #f87171; }
    .response-input { width: 100%; min-height: 60px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; margin-top: 8px; }
    th, td { padding: 8px 6px; text-align: left; border-bottom: 1px solid #1f2937; }
    th { font-size: 11px; text-transform: uppercase; letter-spacing: 0.06em; color: #6b7280; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="card">
      <a href="index.html" class="link">&larr; Back to list</a>
      <h1>Markov Response Editor</h1>
      <div class="sub" id="editorSubtitle">Configure auto-responses for each Markov state and the initial outreach message.</div>

      <div id="status"></div>

      <!-- Initial Outreach Section -->
      <div class="section">
        <div class="section-title">Initial Outreach Message</div>
        <div style="margin-bottom: 8px; font-size: 12px; color: #9ca3af;">
          This message is sent during outbound blasts. Supports placeholders: {"{"}name{"}"}, {"{"}fraternity{"}"}
        </div>
        <textarea id="initialOutreach" placeholder="Hello {name}, we would like to know how {fraternity}'s spring rush could be with a FRESH PNM list..."></textarea>
        <div class="state-actions">
          <button class="save-state-btn" type="button" id="saveInitialOutreachBtn" onclick="saveStateFromTextarea('__initial_outreach__', 'initialOutreach')">Save</button>
          <span class="state-status" id="status-__initial_outreach__"></span>
        </div>
      </div>

      <!-- State Responses Section -->
      <div class="section">
        <div class="section-title">State Responses</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Configure the auto-reply message for each Markov state. Leave empty to skip replies for that state.
        </div>
        <div id="stateResponses"></div>
      </div>

      <!-- JSON Import Section -->
      <div class="section">
        <div class="section-title">JSON Import</div>
        <div style="margin-bottom: 12px; font-size: 12px; color: #9ca3af;">
          Paste JSON to populate all fields. Import automatically saves to backend.
        </div>
        <textarea id="jsonInput" placeholder='{"initial_outreach": "...", "responses": {"state_key": {"response_text": "...", "description": "..."}}}' style="min-height: 150px; font-family: 'Monaco', 'Courier New', monospace; font-size: 12px;"></textarea>
        <div style="margin-top: 12px;">
          <button id="importBtn" type="button" onclick="console.log('[HTML_ONCLICK] Import button clicked via onclick'); if (typeof window.importFromJSON === 'function') { window.importFromJSON(); } else { console.error('[HTML_ONCLICK] window.importFromJSON is not a function!', typeof window.importFromJSON); }">Import JSON</button>
        </div>
        <div id="importStatus" class="import-status" style="display: none;"></div>
      </div>

    </div>
  </div>

  <script type="module">
    // Global error handler to catch any unhandled errors
    window.addEventListener('error', (event) => {
      console.error('[GLOBAL_ERROR] Unhandled error:', event.error);
      console.error('[GLOBAL_ERROR] Message:', event.message);
      console.error('[GLOBAL_ERROR] Filename:', event.filename);
      console.error('[GLOBAL_ERROR] Line:', event.lineno);
      console.error('[GLOBAL_ERROR] Column:', event.colno);
      console.error('[GLOBAL_ERROR] Stack:', event.error?.stack);
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      console.error('[GLOBAL_ERROR] Unhandled promise rejection:', event.reason);
      console.error('[GLOBAL_ERROR] Promise:', event.promise);
    });
    
    import { BACKEND_URL } from '/config.js';
    const BACKEND = BACKEND_URL;

    // Authentication check (owner or rep)
    (async function checkAuth() {
      const apiToken = localStorage.getItem('apiToken');
      if (!apiToken) {
        window.location.href = 'login.html';
        return;
      }

      // Verify token by trying to fetch rep cards (works for both owner and rep)
      try {
        const res = await fetch(`${BACKEND}/rep/cards`, {
          headers: {
            'Authorization': `Bearer ${apiToken}`,
            'Content-Type': 'application/json'
          }
        });

        if (res.status === 401 || res.status === 403) {
          localStorage.removeItem('apiToken');
          window.location.href = 'login.html';
          return;
        }

        if (!res.ok) {
          localStorage.removeItem('apiToken');
          window.location.href = 'login.html';
          return;
        }

        // Token validated - determine if owner or rep and update UI
        try {
          const adminRes = await fetch(`${BACKEND}/admin/users`, {
            headers: {
              'Authorization': `Bearer ${apiToken}`,
              'Content-Type': 'application/json'
            }
          });
          
          if (adminRes.ok) {
            // Owner/admin
            document.getElementById('editorSubtitle').textContent = 
              'Configure global auto-responses for each Markov state and the initial outreach message.';
          } else {
            // Rep
            document.getElementById('editorSubtitle').textContent = 
              'Configure your rep-specific auto-responses for each Markov state and the initial outreach message. Each rep has their own microenvironment.';
          }
        } catch (e) {
          // Default to rep message if can't determine
          document.getElementById('editorSubtitle').textContent = 
            'Configure your rep-specific auto-responses for each Markov state and the initial outreach message.';
        }
      } catch (error) {
        console.error('Auth check failed:', error);
        localStorage.removeItem('apiToken');
        window.location.href = 'login.html';
        return;
      }
    })();

    // Get headers function
    function getHeaders() {
      const apiToken = localStorage.getItem('apiToken');
      if (!apiToken) {
        window.location.href = 'login.html';
        return {};
      }
      return {
        'Authorization': `Bearer ${apiToken}`,
        'Content-Type': 'application/json'
      };
    }
    
    // Log backend URL on load for debugging
    console.log('========================================');
    console.log('ðŸš€ Markov Response Editor initialized');
    console.log('========================================');
    console.log('BACKEND_URL from config:', BACKEND_URL);
    console.log('BACKEND constant:', BACKEND);
    console.log('BACKEND type:', typeof BACKEND);
    console.log('Location:', window.location.href);
    console.log('========================================');

    // States will be loaded from the registry endpoint
    let MARKOV_STATES = [];

    function showStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.className = type;
      statusDiv.textContent = message;
      statusDiv.style.display = 'block';
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 5000);
    }

    async function loadResponses() {
      const headers = getHeaders();
      if (!headers.Authorization) {
        return; // Already redirected
      }

      try {
        console.log('LOAD: BACKEND URL =', BACKEND);
        
        // Step 1: Fetch all states from the registry (authoritative source)
        const statesUrl = `${BACKEND}/markov/states`;
        console.log('LOAD: Fetching states from', statesUrl);
        const statesRes = await fetch(statesUrl, { headers });
        console.log('LOAD: States response status =', statesRes.status);
        if (statesRes.status === 401 || statesRes.status === 403) {
          localStorage.removeItem('apiToken');
          window.location.href = 'login.html';
          return;
        }
        if (!statesRes.ok) {
          throw new Error(`Failed to load states: ${statesRes.status}`);
        }
        MARKOV_STATES = await statesRes.json();
        console.log('LOAD: Loaded', MARKOV_STATES.length, 'states');

        // Step 2: Fetch configured responses from DB (rep-specific if rep, global if owner)
        const responsesUrl = `${BACKEND}/markov/responses`;
        console.log('LOAD: Fetching responses from', responsesUrl);
        const responsesRes = await fetch(responsesUrl, { headers });
        console.log('LOAD: Responses response status =', responsesRes.status);
        if (responsesRes.status === 401 || responsesRes.status === 403) {
          localStorage.removeItem('apiToken');
          window.location.href = 'login.html';
          return;
        }
        if (!responsesRes.ok) {
          throw new Error(`Failed to load responses: ${responsesRes.status}`);
        }
        const responsesData = await responsesRes.json();
        console.log('LOAD: Loaded responses data', Object.keys(responsesData.responses || {}).length, 'configured states');

        // Load initial outreach
        if (responsesData.initial_outreach) {
          document.getElementById('initialOutreach').value = responsesData.initial_outreach;
        }

        // Step 3: Merge states (registry) with responses (config)
        const responses = responsesData.responses || {};
        const container = document.getElementById('stateResponses');
        container.innerHTML = '';

        MARKOV_STATES.forEach(state => {
          // Get config for this state (if it exists)
          const stateConfig = responses[state.state_key] || {};
          const responseText = stateConfig.response_text || '';
          const configDescription = stateConfig.description || '';
          
          // Use description from registry, or fallback to config description
          const description = state.description || configDescription || '';

          const row = document.createElement('div');
          row.className = 'state-row';
          const textareaId = `state-${state.state_key}`;
          const buttonId = `save-${state.state_key}-btn`;
          row.innerHTML = `
            <div class="state-header">
              <div>
                <strong>${state.label || state.state_key}</strong>
                <span class="state-badge" style="background: ${state.color}20; border: 1px solid ${state.color}; color: ${state.color};">${state.state_key}</span>
              </div>
            </div>
            ${description ? `<div class="state-description">${description}</div>` : ''}
            <textarea id="${textareaId}" class="response-input" data-state="${state.state_key}" placeholder="Leave empty to skip replies for this state">${responseText}</textarea>
            <div class="state-actions">
              <button class="save-state-btn" type="button" id="${buttonId}" onclick="saveStateFromTextarea('${state.state_key}', '${textareaId}')">Save</button>
              <span class="state-status" id="status-${state.state_key}"></span>
            </div>
          `;
          container.appendChild(row);
        });

        showStatus('States and responses loaded', 'success');
      } catch (error) {
        showStatus(`Error loading: ${error.message}`, 'error');
        console.error('Load error:', error);
      }
    }

    function setStateStatus(stateKey, status, message = '') {
      const statusEl = document.getElementById(`status-${stateKey}`);
      if (!statusEl) return;
      
      // Remove all status classes
      statusEl.classList.remove('saving', 'success', 'error');
      
      if (status === 'saving') {
        statusEl.classList.add('saving');
        statusEl.textContent = 'Savingâ€¦';
      } else if (status === 'success') {
        statusEl.classList.add('success');
        statusEl.textContent = 'âœ“ Saved';
        // Clear after 2 seconds
        setTimeout(() => {
          if (statusEl.textContent === 'âœ“ Saved') {
            statusEl.textContent = '';
            statusEl.classList.remove('success');
          }
        }, 2000);
      } else if (status === 'error') {
        statusEl.classList.add('error');
        statusEl.textContent = `âœ• ${message || 'Error'}`;
      } else {
        statusEl.textContent = '';
      }
    }

    async function saveState(stateKey, cfg) {
      console.log('[SAVE] ========================================');
      console.log('[SAVE] ðŸŽ¯ FUNCTION ENTERED');
      console.log('[SAVE] Function called', stateKey);
      console.log('[SAVE] Config:', cfg);
      console.log('[SAVE] BACKEND URL:', BACKEND);
      console.log('[SAVE] BACKEND type:', typeof BACKEND);
      console.log('[SAVE] BACKEND value:', String(BACKEND));
      
      setStateStatus(stateKey, 'saving', 'Savingâ€¦');

      try {
        const payload = {
          state_key: stateKey,
          response_text: cfg.response_text || cfg || '',
          description: cfg.description || '',
        };

        const headers = getHeaders();
        if (!headers.Authorization) {
          setStateStatus(stateKey, 'error', 'Not authenticated');
          return false;
        }

        const url = `${BACKEND}/markov/response`;
        console.log('[SAVE] URL:', url);
        console.log('[SAVE] Payload:', JSON.stringify(payload, null, 2));
        console.log('[SAVE] About to call fetch()...');
        console.log('[SAVE] Fetch options:', {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(payload),
        });

        // Create fetch promise and log it immediately
        const fetchPromise = fetch(url, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(payload),
        });
        console.log('[SAVE] âœ… fetch() called, promise created:', fetchPromise);
        console.log('[SAVE] Promise state:', fetchPromise.constructor.name);
        
        // Await the response
        const res = await fetchPromise;
        console.log('[SAVE] âœ… Response received');
        console.log('[SAVE] Response object:', res);
        console.log('[SAVE] Status:', res.status);
        console.log('[SAVE] Status OK:', res.ok);
        console.log('[SAVE] Status text:', res.statusText);
        console.log('[SAVE] Headers:', Object.fromEntries(res.headers.entries()));

        // MUST consume response body - browsers require this
        const data = await res.json();
        console.log('[SAVE] âœ… Response body parsed:', JSON.stringify(data, null, 2));

        if (!res.ok) {
          console.error('[SAVE] âŒ FAILED', stateKey, `HTTP ${res.status}:`, data);
          throw new Error(data.detail || data.message || `HTTP ${res.status}`);
        }

        console.log('[SAVE] âœ… SUCCESS', stateKey);
        console.log('[SAVE] ========================================');
        setStateStatus(stateKey, 'success', 'Saved');
        return true;
      } catch (err) {
        console.error('[SAVE] âŒ EXCEPTION', stateKey);
        console.error('[SAVE] Error object:', err);
        console.error('[SAVE] Error name:', err.name);
        console.error('[SAVE] Error message:', err.message);
        console.error('[SAVE] Error stack:', err.stack);
        if (err.cause) {
          console.error('[SAVE] Error cause:', err.cause);
        }
        console.log('[SAVE] ========================================');
        setStateStatus(stateKey, 'error', err.message);
        return false;
      }
    }

    async function saveStateFromTextarea(stateKey, textareaId) {
      console.log('[SAVE_FROM_TEXTAREA] ========================================');
      console.log('[SAVE_FROM_TEXTAREA] Button clicked!');
      console.log('[SAVE_FROM_TEXTAREA] State key:', stateKey);
      console.log('[SAVE_FROM_TEXTAREA] Textarea ID:', textareaId);
      
      const textarea = document.getElementById(textareaId);
      const buttonId = textareaId === 'initialOutreach' ? 'saveInitialOutreachBtn' : `save-${stateKey}-btn`;
      const button = document.getElementById(buttonId);
      
      console.log('[SAVE_FROM_TEXTAREA] Textarea element:', textarea);
      console.log('[SAVE_FROM_TEXTAREA] Button element:', button);
      
      if (!textarea) {
        console.error('[SAVE_FROM_TEXTAREA] âŒ Textarea not found', textareaId);
        console.log('[SAVE_FROM_TEXTAREA] ========================================');
        return false;
      }

      if (button) {
        button.disabled = true;
        console.log('[SAVE_FROM_TEXTAREA] Button disabled');
      }

      try {
        const responseText = textarea.value.trim();
        console.log('[SAVE_FROM_TEXTAREA] Text value length:', responseText.length);
        console.log('[SAVE_FROM_TEXTAREA] Calling saveState...');
        const success = await saveState(stateKey, { response_text: responseText });
        console.log('[SAVE_FROM_TEXTAREA] Save result:', success);
        console.log('[SAVE_FROM_TEXTAREA] ========================================');
        return success;
      } finally {
        if (button) {
          button.disabled = false;
          console.log('[SAVE_FROM_TEXTAREA] Button re-enabled');
        }
      }
    }


    function log(...args) {
      console.log('[MARKOV_UI]', ...args);
    }
    
    // Keep logUI for backward compatibility
    function logUI(event, data = '') {
      log(event, data);
    }

    function hydrateUIFromJSON(payload) {
      logUI('hydrate:start', Object.keys(payload));
      
      // Update initial outreach
      if (payload.initial_outreach) {
        const initialTextarea = document.getElementById('initialOutreach');
        if (initialTextarea) {
          initialTextarea.value = payload.initial_outreach;
          setStateStatus('__initial_outreach__', 'success', 'Updated');
          logUI('hydrate:initial_outreach', 'updated');
        }
      }

      // Update state responses
      if (payload.responses && typeof payload.responses === 'object') {
        Object.entries(payload.responses).forEach(([stateKey, stateData]) => {
          const responseText = stateData.response_text || stateData.responseText || '';
          const textareaId = `state-${stateKey}`;
          const textarea = document.getElementById(textareaId);
          
          if (!textarea) {
            setStateStatus(stateKey, 'error', 'State not found');
            logUI('hydrate:state:notfound', stateKey);
            return;
          }

          textarea.value = responseText;
          setStateStatus(stateKey, 'success', 'Updated');
          logUI('hydrate:state:updated', stateKey);
        });
      }
      
      logUI('hydrate:complete');
    }

    function showImportSummary(ok, skipped, failed) {
      const statusEl = document.getElementById('importStatus');
      if (!statusEl) return;
      
      statusEl.style.display = 'block';
      statusEl.classList.remove('success', 'warning', 'error');
      
      const parts = [];
      if (ok > 0) {
        parts.push(`âœ” Imported ${ok} ${ok === 1 ? 'state' : 'states'}`);
      }
      if (skipped > 0) {
        parts.push(`âš  ${skipped} ${skipped === 1 ? 'state' : 'states'} skipped (unknown)`);
      }
      if (failed > 0) {
        parts.push(`âœ• ${failed} ${failed === 1 ? 'state' : 'states'} failed`);
      }
      
      if (failed > 0) {
        statusEl.classList.add('error');
      } else if (skipped > 0) {
        statusEl.classList.add('warning');
      } else {
        statusEl.classList.add('success');
      }
      
      statusEl.textContent = parts.join(' | ');
    }

    async function importFromJSON(event) {
      console.log('[IMPORT] ========================================');
      console.log('[IMPORT] ðŸŽ¯ðŸŽ¯ðŸŽ¯ IMPORT FUNCTION CALLED ðŸŽ¯ðŸŽ¯ðŸŽ¯');
      console.log('[IMPORT] Event:', event);
      console.log('[IMPORT] Event type:', typeof event);
      console.log('[IMPORT] This context:', this);
      console.log('[IMPORT] Call stack:', new Error().stack);
      
      // Prevent any form submission
      if (event) {
        event.preventDefault();
        event.stopPropagation();
        console.log('[IMPORT] Event prevented');
      } else {
        console.log('[IMPORT] No event object (called from onclick)');
      }
      
      const importBtn = document.getElementById('importBtn');
      console.log('[IMPORT] Import button element:', importBtn);
      const originalText = importBtn ? importBtn.textContent : 'Import JSON';
      if (importBtn) {
        importBtn.disabled = true;
        importBtn.textContent = 'Importing...';
        console.log('[IMPORT] Button disabled and text changed');
      }

      const statusEl = document.getElementById('importStatus');
      if (statusEl) {
        statusEl.style.display = 'block';
        statusEl.classList.remove('success', 'warning', 'error');
        statusEl.classList.add('warning');
        statusEl.textContent = 'Parsing JSONâ€¦';
      }

      let ok = 0;
      let skipped = 0;
      let failed = 0;

      try {
        const jsonInput = document.getElementById('jsonInput');
        console.log('[IMPORT] JSON input element:', jsonInput);
        const jsonText = jsonInput ? jsonInput.value.trim() : '';
        console.log('[IMPORT] JSON text length:', jsonText.length);
        
        if (!jsonText) {
          console.error('[IMPORT] âŒ Empty JSON');
          if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.classList.remove('warning');
            statusEl.classList.add('error');
            statusEl.textContent = 'âœ• Please enter JSON to import';
          }
          return;
        }

        let parsed;
        try {
          parsed = JSON.parse(jsonText);
          console.log('[IMPORT] âœ… JSON parsed successfully');
          console.log('[IMPORT] Parsed JSON keys:', Object.keys(parsed));
          console.log('[IMPORT] Parsed JSON:', JSON.stringify(parsed, null, 2));
        } catch (e) {
          console.error('[IMPORT] âŒ JSON parse error:', e);
          console.error('[IMPORT] Parse error message:', e.message);
          if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.classList.remove('warning');
            statusEl.classList.add('error');
            statusEl.textContent = 'âœ• Invalid JSON';
          }
          return;
        }

        // 1ï¸âƒ£ Initial outreach
        if (parsed.initial_outreach) {
          console.log('[IMPORT] Processing initial_outreach');
          const initialTextarea = document.getElementById('initialOutreach');
          console.log('[IMPORT] Initial textarea element:', initialTextarea);
          if (initialTextarea) {
            initialTextarea.value = parsed.initial_outreach;
            console.log('[IMPORT] Calling saveState for initial_outreach...');
            const success = await saveState('__initial_outreach__', { response_text: parsed.initial_outreach });
            console.log('[IMPORT] Initial outreach save result:', success);
            if (success) {
              ok++;
            } else {
              failed++;
            }
          }
        }

        // 2ï¸âƒ£ Per-state propagation
        if (parsed.responses && typeof parsed.responses === 'object') {
          const stateKeys = Object.keys(parsed.responses);
          console.log('[IMPORT] Processing', stateKeys.length, 'state responses');
          console.log('[IMPORT] State keys:', stateKeys);
          
          for (const [stateKey, cfg] of Object.entries(parsed.responses)) {
            console.log('[IMPORT] Processing state:', stateKey);
            console.log('[IMPORT] State config:', cfg);

            const textarea = document.querySelector(`textarea[data-state="${stateKey}"]`) || 
                           document.getElementById(`state-${stateKey}`);
            console.log('[IMPORT] State textarea element:', textarea);

            if (!textarea) {
              console.error('[IMPORT] âŒ STATE NOT FOUND IN UI:', stateKey);
              setStateStatus(stateKey, 'error', 'State not found in UI');
              skipped++;
              continue;
            }

            textarea.value = cfg.response_text || cfg.responseText || '';
            console.log('[IMPORT] Calling saveState for state:', stateKey);
            const success = await saveState(stateKey, cfg);
            console.log('[IMPORT] State save result:', success, 'for', stateKey);
            if (success) {
              ok++;
            } else {
              failed++;
            }
          }
        }

        console.log('[IMPORT] âœ… Import complete');
        console.log('[IMPORT] Summary:', { ok, skipped, failed });
        console.log('[IMPORT] ========================================');
        showImportSummary(ok, skipped, failed);

      } catch (error) {
        console.error('[IMPORT] âŒ IMPORT ERROR');
        console.error('[IMPORT] Error:', error);
        console.error('[IMPORT] Error message:', error.message);
        console.error('[IMPORT] Error stack:', error.stack);
        console.log('[IMPORT] ========================================');
        if (statusEl) {
          statusEl.style.display = 'block';
          statusEl.classList.remove('success', 'warning');
          statusEl.classList.add('error');
          statusEl.textContent = `âœ• Import error: ${error.message}`;
        }
      } finally {
        if (importBtn) {
          importBtn.disabled = false;
          importBtn.textContent = originalText;
          console.log('[IMPORT] Button re-enabled');
        }
      }
    }

    // Expose functions to global scope for onclick handlers
    window.saveStateFromTextarea = saveStateFromTextarea;
    window.importFromJSON = importFromJSON;
    window.saveState = saveState;
    
    // Verify functions are exposed
    console.log('[MARKOV_UI] âœ… Functions exposed to window');
    console.log('[MARKOV_UI] window.saveStateFromTextarea:', typeof window.saveStateFromTextarea);
    console.log('[MARKOV_UI] window.importFromJSON:', typeof window.importFromJSON);
    console.log('[MARKOV_UI] window.saveState:', typeof window.saveState);
    
    // Test that functions are callable
    if (typeof window.importFromJSON === 'function') {
      console.log('[MARKOV_UI] âœ… importFromJSON is callable');
    } else {
      console.error('[MARKOV_UI] âŒ importFromJSON is NOT a function!');
    }
    
    // Add explicit event listeners as backup to onclick handlers
    window.addEventListener('DOMContentLoaded', () => {
      console.log('[MARKOV_UI] DOM Content Loaded');
      console.log('[MARKOV_UI] Checking button bindings...');
      
      const importBtn = document.getElementById('importBtn');
      console.log('[MARKOV_UI] Import button:', importBtn);
      console.log('[MARKOV_UI] Import button onclick:', importBtn ? importBtn.getAttribute('onclick') : 'null');
      console.log('[MARKOV_UI] window.importFromJSON:', typeof window.importFromJSON);
      
      // Add explicit click listener as backup
      if (importBtn && typeof window.importFromJSON === 'function') {
        importBtn.addEventListener('click', (e) => {
          console.log('[MARKOV_UI] ðŸ”¥ EXPLICIT CLICK LISTENER FIRED');
          console.log('[MARKOV_UI] Event:', e);
          e.preventDefault();
          e.stopPropagation();
          window.importFromJSON(e);
        });
        console.log('[MARKOV_UI] âœ… Added explicit click listener to import button');
      }
      
      const saveInitialBtn = document.getElementById('saveInitialOutreachBtn');
      console.log('[MARKOV_UI] Save initial button:', saveInitialBtn);
      console.log('[MARKOV_UI] Save initial onclick:', saveInitialBtn ? saveInitialBtn.getAttribute('onclick') : 'null');
      console.log('[MARKOV_UI] window.saveStateFromTextarea:', typeof window.saveStateFromTextarea);
      
      // Add explicit listeners to all save buttons
      document.querySelectorAll('.save-state-btn').forEach(btn => {
        const onclick = btn.getAttribute('onclick');
        if (onclick && onclick.includes('saveStateFromTextarea')) {
          btn.addEventListener('click', (e) => {
            console.log('[MARKOV_UI] ðŸ”¥ EXPLICIT SAVE BUTTON CLICK LISTENER FIRED');
            console.log('[MARKOV_UI] Button:', btn);
            console.log('[MARKOV_UI] Original onclick:', onclick);
            // Let the onclick handler run, but log it
          });
        }
      });
      
      console.log('[MARKOV_UI] âœ… All event listeners attached');
    });

    // Load on page load
    loadResponses();
  </script>
</body>
</html>
